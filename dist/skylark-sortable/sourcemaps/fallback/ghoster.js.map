{"version":3,"sources":["fallback/ghoster.js"],"names":["define","skylark","langx","isBrowser","isMobile","$","browser","noder","finder","geom","styler","eventer","transforms","oriented","touch","_getRect","el","adjustForTransform","container","adjustForFixed","getBoundingClientRect","window","top","left","bottom","right","width","height","boundingRect","matrix","scaleX","a","scaleY","d","ghostEl","PositionGhostAbsolutely","apple","device","ghostRelativeParent","ghostRelativeParentInitialScroll","_appendGhost","dragEl","options","this","rect","css","document","parentNode","ghostRelativeParentRect","body","documentElement","scrollingElement","scrollTop","scrollLeft","offsets","scrollOffset","offsetLeft","offsetTop","cloneNode","toggleClass","ghostClass","fallbackClass","dragClass","box-sizing","margin","opacity","position","zIndex","pointerEvents","appendChild","getRelativeScrollOffset","autoscroll","_getRelativeScrollOffset","remove"],"mappings":";;;;;;;AAAAA,QACC,wBACA,sBACA,kCACA,iCACA,qBACA,uBACA,qBACA,sBACA,oBACA,sBACA,uBACA,0BACA,gCACA,gCACC,SACDC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,GAEG,aASH,SAASC,EAASC,EAAIC,EAAoBC,EAAWC,GACpD,GAAKH,EAAGI,uBAAyBJ,IAAOK,OAAxC,CACA,IAAIC,IACHA,EAAGC,KACHA,EAAIC,OACJA,EAAMC,MACNA,EAAKC,MACLA,EAAKC,OACLA,GACGlB,EAAKmB,aAAaZ,GAEtB,GAAIC,GAAsBD,IAAOK,OAAQ,CAExC,IAAIQ,EAASjB,EAAWiB,OAAOX,GAAaF,GAC3Cc,EAASD,GAAUA,EAAOE,EAC1BC,EAASH,GAAUA,EAAOI,EAEvBJ,IAOHL,GANAF,GAAOU,IAIPL,GAAUK,GAGVP,GANAF,GAAQO,IAERJ,GAASI,IAQX,OACCR,IAAKA,EACLC,KAAMA,EACNC,OAAQA,EACRC,MAAOA,EACPC,MAAOA,EACPC,OAAQA,IAkGV,OA5FCO,QAAU,KAEVC,wBAA0B/B,EAASgC,MAAMC,OAEzCC,oBAAsB,KACtBC,oCAEAC,aAAc,SAAUC,EAAOvB,EAAUwB,GAGxC,IACCR,EAAUS,KAAKT,QAEhB,IAAKA,EAAS,CACb,IACCU,EAAO7B,EAAS0B,GAAQ,EAAMvB,EAAYyB,KAAKR,yBACzCzB,EAAOmC,IAAIJ,GAIlB,GAAIE,KAAKR,wBAAyB,CAIjC,IAFA,IAAIG,EAAsBK,KAAKL,oBAAsBpB,EAGJ,WAAhDR,EAAOmC,IAAIP,EAAqB,aACiB,SAAjD5B,EAAOmC,IAAIP,EAAqB,cAChCA,IAAwBQ,UAExBR,EAAsBA,EAAoBS,WAG3C,GAAIT,IAAwBQ,SAAU,CACrC,IAAIE,EAA0BjC,EAASuB,GAAqB,GAE5DM,EAAKtB,KAAO0B,EAAwB1B,IACpCsB,EAAKrB,MAAQyB,EAAwBzB,KAGlCe,IAAwBQ,SAASG,MAAQX,IAAwBQ,SAASI,iBACzEZ,IAAwBQ,WAC3BR,EAAsBK,KAAKL,oBAAsB/B,EAAM4C,oBAGxDP,EAAKtB,KAAOgB,EAAoBc,UAChCR,EAAKrB,MAAQe,EAAoBe,YAEjCf,EAAsBK,KAAKL,oBAAsB/B,EAAM4C,mBAExD,IAAIG,EAAU7C,EAAK8C,aAAajB,GAChCC,kCAAoCe,EAAQE,WAAWF,EAAQG,WAIhEvB,EAASS,KAAKT,QAAUO,EAAOiB,WAAU,GAEzChD,EAAOiD,YAAYzB,EAASQ,EAAQkB,YAAY,GAChDlD,EAAOiD,YAAYzB,EAASQ,EAAQmB,eAAe,GACnDnD,EAAOiD,YAAYzB,EAASQ,EAAQoB,WAAW,GAG/CpD,EAAOmC,IAAIX,GACV6B,aAAc,aACdC,OAAU,EACV1C,IAAOsB,EAAKtB,IACZC,KAAQqB,EAAKrB,KACbG,MAASkB,EAAKlB,MACdC,OAAUiB,EAAKjB,OACfsC,QAAW,MACXC,SAAavB,KAAKR,wBAA0B,WAAa,QACzDgC,OAAU,SACVC,cAAiB,SAElBlD,EAAUmD,YAAYnC,KAIxBoC,wBAA0B,WACzB,OAAO3B,KAAKR,yBAA2BQ,KAAKL,qBAAuBiC,WAAWC,yBAAyB7B,KAAKL,sBAG7GmC,OAAS,WACJ9B,KAAKT,SACR3B,EAAMkE,OAAO9B,KAAKT,SAEnBS,KAAKT,QAAU","file":"../../fallback/ghoster.js","sourcesContent":["define([\n\t\"skylark-langx/skylark\",\n\t\"skylark-langx/langx\",\n\t\"skylark-langx-hoster/is-browser\",\n\t\"skylark-langx-hoster/is-mobile\",\n\t\"skylark-domx-query\",\n\t\"skylark-domx-browser\",\n\t\"skylark-domx-noder\",\n\t\"skylark-domx-finder\",\n\t\"skylark-domx-geom\",\n\t\"skylark-domx-styler\",\n\t\"skylark-domx-eventer\",\n\t\"skylark-domx-transforms\",\n\t\"skylark-domx-layouts/oriented\",\n\t\"skylark-devices-points/touch\"\n],function(\n\tskylark,\n\tlangx,\n\tisBrowser,\n\tisMobile,\n\t$,\n\tbrowser,\n\tnoder,\n\tfinder,\n\tgeom,\n\tstyler,\n\teventer,\n\ttransforms,\n\toriented,\n\ttouch\n){\n    'use strict';\n\n\t/**\n\t * Returns the \"bounding client rect\" of given element\n\t * @param  {HTMLElement} el                The element whose boundingClientRect is wanted\n\t * @param  {[HTMLElement]} container       the parent the element will be placed in\n\t * @param  {[Boolean]} adjustForTransform  Whether the rect should compensate for parent's transform\n\t * @return {Object}                        The boundingClientRect of el\n\t */\n\tfunction _getRect(el, adjustForTransform, container, adjustForFixed) {\n\t\tif (!el.getBoundingClientRect && el !== window) return;\n\t\tvar {\n\t\t\ttop,\n\t\t\tleft,\n\t\t\tbottom,\n\t\t\tright,\n\t\t\twidth,\n\t\t\theight\n\t\t} = geom.boundingRect(el);\n\t\t\n\t\tif (adjustForTransform && el !== window) {\n\t\t\t// Adjust for scale()\n\t\t\tvar matrix = transforms.matrix(container || el),\n\t\t\t\tscaleX = matrix && matrix.a,\n\t\t\t\tscaleY = matrix && matrix.d;\n\n\t\t\tif (matrix) {\n\t\t\t\ttop /= scaleY;\n\t\t\t\tleft /= scaleX;\n\n\t\t\t\twidth /= scaleX;\n\t\t\t\theight /= scaleY;\n\n\t\t\t\tbottom = top + height;\n\t\t\t\tright = left + width;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttop: top,\n\t\t\tleft: left,\n\t\t\tbottom: bottom,\n\t\t\tright: right,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\n\n\tvar ghoster = {\n\t\tghostEl : null,\n\n\t\tPositionGhostAbsolutely : isMobile.apple.device, //IOS\n\t\t// For positioning ghost absolutely\n\t\tghostRelativeParent : null,\n\t\tghostRelativeParentInitialScroll : [], // (left, top)\n\n\t\t_appendGhost: function (dragEl,container,options) {\n\t\t\t// Bug if using scale(): https://stackoverflow.com/questions/2637058\n\t\t\t// Not being adjusted for\n\t\t\tvar /// dragEl = dnd.dragEl,\n\t\t\t\tghostEl = this.ghostEl;\n\n\t\t\tif (!ghostEl) {\n\t\t\t\tvar ///container = this.options.fallbackOnBody ? document.body : rootEl,\n\t\t\t\t\trect = _getRect(dragEl, true, container, !this.PositionGhostAbsolutely),\n\t\t\t\t\tcss = styler.css(dragEl);\n\t\t\t\t\t///options = this.options;\n\n\t\t\t\t// Position absolutely\n\t\t\t\tif (this.PositionGhostAbsolutely) {\n\t\t\t\t\t// Get relatively positioned parent\n\t\t\t\t\tvar ghostRelativeParent = this.ghostRelativeParent = container;\n\n\t\t\t\t\twhile (\n\t\t\t\t\t\tstyler.css(ghostRelativeParent, 'position') === 'static' &&\n\t\t\t\t\t\tstyler.css(ghostRelativeParent, 'transform') === 'none' &&\n\t\t\t\t\t\tghostRelativeParent !== document\n\t\t\t\t\t) {\n\t\t\t\t\t\tghostRelativeParent = ghostRelativeParent.parentNode;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ghostRelativeParent !== document) {\n\t\t\t\t\t\tvar ghostRelativeParentRect = _getRect(ghostRelativeParent, true);\n\n\t\t\t\t\t\trect.top -= ghostRelativeParentRect.top;\n\t\t\t\t\t\trect.left -= ghostRelativeParentRect.left;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n\t\t\t\t\t\tif (ghostRelativeParent === document) {\n\t\t\t\t\t\t\tghostRelativeParent = this.ghostRelativeParent = noder.scrollingElement();\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\n\t\t\t\t\t\trect.top += ghostRelativeParent.scrollTop;\n\t\t\t\t\t\trect.left += ghostRelativeParent.scrollLeft;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tghostRelativeParent = this.ghostRelativeParent = noder.scrollingElement();\n\t\t\t\t\t}\n\t\t\t\t\tvar offsets = geom.scrollOffset(ghostRelativeParent);\n\t\t\t\t\tghostRelativeParentInitialScroll = [offsets.offsetLeft,offsets.offsetTop]\n\t\t\t\t}\n\n\n\t\t\t\tghostEl =this.ghostEl = dragEl.cloneNode(true);\n\n\t\t\t\tstyler.toggleClass(ghostEl, options.ghostClass, false);\n\t\t\t\tstyler.toggleClass(ghostEl, options.fallbackClass, true);\n\t\t\t\tstyler.toggleClass(ghostEl, options.dragClass, true);\n\n\n\t\t\t\tstyler.css(ghostEl, {\n\t\t\t\t\t'box-sizing': 'border-box',\n\t\t\t\t\t'margin': 0,\n\t\t\t\t\t'top': rect.top,\n\t\t\t\t\t'left': rect.left,\n\t\t\t\t\t'width': rect.width,\n\t\t\t\t\t'height': rect.height,\n\t\t\t\t\t'opacity': '0.8',\n\t\t\t\t\t'position': (this.PositionGhostAbsolutely ? 'absolute' : 'fixed'),\n\t\t\t\t\t'zIndex': '100000',\n\t\t\t\t\t'pointerEvents': 'none'\t\n\t\t\t\t});\n\t\t\t\tcontainer.appendChild(ghostEl);\n\t\t\t}\n\t\t},\n\n\t\tgetRelativeScrollOffset : function(){\n\t\t\treturn this.PositionGhostAbsolutely && this.ghostRelativeParent && autoscroll._getRelativeScrollOffset(this.ghostRelativeParent);\n\t\t},\n\n\t\tremove : function() {\n\t\t\tif (this.ghostEl) {\n\t\t\t\tnoder.remove(this.ghostEl);\n\t\t\t} \n\t\t\tthis.ghostEl = null;\n\n\t\t}\n\n\n\t};\n\n\treturn ghoster;\n\t\n});"]}