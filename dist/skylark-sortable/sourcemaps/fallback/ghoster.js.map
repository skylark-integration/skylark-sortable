{"version":3,"sources":["fallback/ghoster.js"],"names":["define","skylark","langx","isBrowser","isMobile","$","browser","noder","finder","geom","styler","eventer","transforms","scrollingElement","oriented","touch","_getRect","el","adjustForTransform","container","adjustForFixed","getBoundingClientRect","window","top","left","bottom","right","width","height","boundingRect","matrix","scaleX","a","scaleY","d","ghostEl","PositionGhostAbsolutely","apple","device","ghostRelativeParent","ghostRelativeParentInitialScroll","_ghostIsLast","evt","axis","elRect","lastChild","ignoreHidden","excluding","this","mouseOnAxis","clientY","clientX","mouseOnOppAxis","targetS2","targetS1Opp","targetS2Opp","_lastChild","_appendGhost","dragEl","options","rect","css","document","parentNode","ghostRelativeParentRect","body","documentElement","scrollTop","scrollLeft","autoscroll","_getRelativeScrollOffset","cloneNode","toggleClass","ghostClass","fallbackClass","dragClass","box-sizing","margin","opacity","position","zIndex","pointerEvents","appendChild","getRelativeScrollOffset","remove"],"mappings":"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","file":"../../fallback/ghoster.js","sourcesContent":["define([\n\t\"skylark-langx/skylark\",\n\t\"skylark-langx/langx\",\n\t\"skylark-langx-hoster/isBrowser\",\n\t\"skylark-langx-hoster/isMobile\",\n\t\"skylark-domx-query\",\n\t\"skylark-domx-browser\",\n\t\"skylark-domx-noder\",\n\t\"skylark-domx-finder\",\n\t\"skylark-domx-geom\",\n\t\"skylark-domx-styler\",\n\t\"skylark-domx-eventer\",\n\t\"skylark-domx-transforms\",\n\t\"skylark-domx-scrolls/scrollingElement\",\n\t\"skylark-domx-layouts/oriented\",\n\t\"skylark-devices-points/touch\"\n],function(\n\tskylark,\n\tlangx,\n\tisBrowser,\n\tisMobile,\n\t$,\n\tbrowser,\n\tnoder,\n\tfinder,\n\tgeom,\n\tstyler,\n\teventer,\n\ttransforms,\n\tscrollingElement,\n\toriented,\n\ttouch\n){\n    'use strict';\n\n\t/**\n\t * Returns the \"bounding client rect\" of given element\n\t * @param  {HTMLElement} el                The element whose boundingClientRect is wanted\n\t * @param  {[HTMLElement]} container       the parent the element will be placed in\n\t * @param  {[Boolean]} adjustForTransform  Whether the rect should compensate for parent's transform\n\t * @return {Object}                        The boundingClientRect of el\n\t */\n\tfunction _getRect(el, adjustForTransform, container, adjustForFixed) {\n\t\tif (!el.getBoundingClientRect && el !== window) return;\n\t\tvar {\n\t\t\ttop,\n\t\t\tleft,\n\t\t\tbottom,\n\t\t\tright,\n\t\t\twidth,\n\t\t\theight\n\t\t} = geom.boundingRect(el);\n\t\t\n\t\tif (adjustForTransform && el !== window) {\n\t\t\t// Adjust for scale()\n\t\t\tvar matrix = transforms.matrix(container || el),\n\t\t\t\tscaleX = matrix && matrix.a,\n\t\t\t\tscaleY = matrix && matrix.d;\n\n\t\t\tif (matrix) {\n\t\t\t\ttop /= scaleY;\n\t\t\t\tleft /= scaleX;\n\n\t\t\t\twidth /= scaleX;\n\t\t\t\theight /= scaleY;\n\n\t\t\t\tbottom = top + height;\n\t\t\t\tright = left + width;\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttop: top,\n\t\t\tleft: left,\n\t\t\tbottom: bottom,\n\t\t\tright: right,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\n\n\tvar ghoster = {\n\t\tghostEl : null,\n\n\t\tPositionGhostAbsolutely : isMobile.apple.device, //IOS\n\t\t// For positioning ghost absolutely\n\t\tghostRelativeParent : null,\n\t\tghostRelativeParentInitialScroll : [], // (left, top)\n\n\t\t_ghostIsLast : function (evt, axis, el) {\n\t\t\tvar elRect = geom.boundingRect(finder.lastChild(el,{ignoreHidden : true,excluding : [this.ghostEl]})),\n\t\t\t\tmouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,\n\t\t\t\tmouseOnOppAxis = axis === 'vertical' ? evt.clientX : evt.clientY,\n\t\t\t\ttargetS2 = axis === 'vertical' ? elRect.bottom : elRect.right,\n\t\t\t\ttargetS1Opp = axis === 'vertical' ? elRect.left : elRect.top,\n\t\t\t\ttargetS2Opp = axis === 'vertical' ? elRect.right : elRect.bottom,\n\t\t\t\tspacer = 10;\n\n\t\t\treturn (\n\t\t\t\taxis === 'vertical' ?\n\t\t\t\t\t(mouseOnOppAxis > targetS2Opp + spacer || mouseOnOppAxis <= targetS2Opp && mouseOnAxis > targetS2 && mouseOnOppAxis >= targetS1Opp) :\n\t\t\t\t\t(mouseOnAxis > targetS2 && mouseOnOppAxis > targetS1Opp || mouseOnAxis <= targetS2 && mouseOnOppAxis > targetS2Opp + spacer)\n\t\t\t);\n\t\t},\n\n\n\t\t/**\n\t\t * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n\t\t * @param  {HTMLElement} el       Parent element\n\t\t * @return {HTMLElement}          The last child, ignoring ghostEl\n\t\t */\n\t\t_lastChild : function (el) {\n\t\t\t/*\n\t\t\tvar last = el.lastElementChild;\n\n\t\t\twhile (last && (last === ghostEl || styler.css(last, 'display') === 'none')) {\n\t\t\t\tlast = last.previousElementSibling;\n\t\t\t}\n\n\t\t\treturn last || null;\n\t\t\t*/\n\t\t\treturn finder.lastChild(el,{\n\t\t\t\tignoreHidden : true,\n\t\t\t\texcluding : [this.ghostEl]\n\t\t\t})\n\t\t},\n\n\t\t_appendGhost: function (dragEl,container,options) {\n\t\t\t// Bug if using scale(): https://stackoverflow.com/questions/2637058\n\t\t\t// Not being adjusted for\n\t\t\tvar /// dragEl = dnd.dragEl,\n\t\t\t\tghostEl = this.ghostEl;\n\n\t\t\tif (!ghostEl) {\n\t\t\t\tvar ///container = this.options.fallbackOnBody ? document.body : rootEl,\n\t\t\t\t\trect = _getRect(dragEl, true, container, !this.PositionGhostAbsolutely),\n\t\t\t\t\tcss = styler.css(dragEl);\n\t\t\t\t\t///options = this.options;\n\n\t\t\t\t// Position absolutely\n\t\t\t\tif (this.PositionGhostAbsolutely) {\n\t\t\t\t\t// Get relatively positioned parent\n\t\t\t\t\tvar ghostRelativeParent = this.ghostRelativeParent = container;\n\n\t\t\t\t\twhile (\n\t\t\t\t\t\tstyler.css(ghostRelativeParent, 'position') === 'static' &&\n\t\t\t\t\t\tstyler.css(ghostRelativeParent, 'transform') === 'none' &&\n\t\t\t\t\t\tghostRelativeParent !== document\n\t\t\t\t\t) {\n\t\t\t\t\t\tghostRelativeParent = ghostRelativeParent.parentNode;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ghostRelativeParent !== document) {\n\t\t\t\t\t\tvar ghostRelativeParentRect = _getRect(ghostRelativeParent, true);\n\n\t\t\t\t\t\trect.top -= ghostRelativeParentRect.top;\n\t\t\t\t\t\trect.left -= ghostRelativeParentRect.left;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {\n\t\t\t\t\t\tif (ghostRelativeParent === document) {\n\t\t\t\t\t\t\tghostRelativeParent = this.ghostRelativeParent = scrollingElement();\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\n\t\t\t\t\t\trect.top += ghostRelativeParent.scrollTop;\n\t\t\t\t\t\trect.left += ghostRelativeParent.scrollLeft;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tghostRelativeParent = this.ghostRelativeParent = scrollingElement();\n\t\t\t\t\t}\n\t\t\t\t\tghostRelativeParentInitialScroll = autoscroll._getRelativeScrollOffset(ghostRelativeParent);\n\t\t\t\t}\n\n\n\t\t\t\tghostEl =this.ghostEl = dragEl.cloneNode(true);\n\n\t\t\t\tstyler.toggleClass(ghostEl, options.ghostClass, false);\n\t\t\t\tstyler.toggleClass(ghostEl, options.fallbackClass, true);\n\t\t\t\tstyler.toggleClass(ghostEl, options.dragClass, true);\n\n\t\t\t\t/*\n\t\t\t\tstyler.css(ghostEl, 'box-sizing', 'border-box');\n\t\t\t\tstyler.css(ghostEl, 'margin', 0);\n\t\t\t\tstyler.css(ghostEl, 'top', rect.top);\n\t\t\t\tstyler.css(ghostEl, 'left', rect.left);\n\t\t\t\tstyler.css(ghostEl, 'width', rect.width);\n\t\t\t\tstyler.css(ghostEl, 'height', rect.height);\n\t\t\t\tstyler.css(ghostEl, 'opacity', '0.8');\n\t\t\t\tstyler.css(ghostEl, 'position', (this.PositionGhostAbsolutely ? 'absolute' : 'fixed'));\n\t\t\t\tstyler.css(ghostEl, 'zIndex', '100000');\n\t\t\t\tstyler.css(ghostEl, 'pointerEvents', 'none');\n\t\t\t\t*/\n\n\t\t\t\tstyler.css(ghostEl, {\n\t\t\t\t\t'box-sizing': 'border-box',\n\t\t\t\t\t'margin': 0,\n\t\t\t\t\t'top': rect.top,\n\t\t\t\t\t'left': rect.left,\n\t\t\t\t\t'width': rect.width,\n\t\t\t\t\t'height': rect.height,\n\t\t\t\t\t'opacity': '0.8',\n\t\t\t\t\t'position': (this.PositionGhostAbsolutely ? 'absolute' : 'fixed'),\n\t\t\t\t\t'zIndex': '100000',\n\t\t\t\t\t'pointerEvents': 'none'\t\n\t\t\t\t});\n\t\t\t\tcontainer.appendChild(ghostEl);\n\t\t\t}\n\t\t},\n\n\t\tgetRelativeScrollOffset : function(){\n\t\t\treturn this.PositionGhostAbsolutely && this.ghostRelativeParent && autoscroll._getRelativeScrollOffset(this.ghostRelativeParent);\n\t\t},\n\n\t\tremove : function() {\n\t\t\tif (this.ghostEl) {\n\t\t\t\tnoder.remove(this.ghostEl);\n\t\t\t} \n\t\t\tthis.ghostEl = null;\n\n\t\t}\n\n\n\t};\n\n\treturn ghoster;\n\t\n});"]}