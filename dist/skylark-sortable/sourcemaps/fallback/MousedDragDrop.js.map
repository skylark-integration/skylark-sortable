{"version":3,"sources":["fallback/MousedDragDrop.js"],"names":["define","langx","$","eventer","styler","transforms","autoscroll","ghoster","Emitter","inherit","_construct","dnd","this","$doc","document","listenTo","_onTouchMove","bind","_onMouseUp","evt","putSortable","_onDrop","draggable","_onDragEnd","remove","destroy","forAutoScroll","ghostEl","dragEl","tapEvt","options","fallbackTolerance","fallbackOffset","touch","touches","matrix","scaleX","a","scaleY","d","relativeScrollOffset","getRelativeScrollOffset","dx","clientX","x","ghostRelativeParentInitialScroll","dy","clientY","y","translate3d","active","awaitingDragStarted","Math","min","abs","_lastX","_lastY","_onDragStart","_appendGhost","body","ignoreNextClick","_loopId","setInterval","_emulateDragOver","_handleAutoScroll","touchEvt","css","preventDefault","target","elementFromPoint","parent","shadowRoot","expando","_onDragOver","rootEl","parentNode","_computeIsAligned","fallback","scroll","unlistenTo","clearInterval","_nulling","_clearAutoScrolls","_cancelThrottle"],"mappings":"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","file":"../../fallback/MousedDragDrop.js","sourcesContent":["define([\r\n\t\"skylark-langx/langx\",\r\n\t\"skylark-domx-query\",\r\n\t\"skylark-domx-eventer\",\r\n\t\"skylark-domx-styler\",\r\n\t\"skylark-domx-transforms\",\r\n\t\"./autoscroll\",\r\n\t\"./ghoster\"\r\n],function(\r\n\tlangx,\r\n\t$,\r\n\teventer,\r\n\tstyler,\r\n\ttransforms,\r\n\tautoscroll,\r\n\tghoster\r\n){\r\n\tvar MousedDragDrop = langx.Emitter.inherit({\r\n\t\t_construct : function(dnd) {\r\n\t\t\tthis.dnd = dnd;\r\n\r\n\t\t\tvar $doc = $(document);\r\n\r\n\t\t\tthis.listenTo($doc,\"mousemove\",this._onTouchMove.bind(this));\r\n\t\t\tthis.listenTo($doc,\"mouseup\",this._onMouseUp.bind(this));\r\n\r\n\t\t},\r\n\r\n\t\t_onMouseUp : function(evt) {\r\n\t\t\tvar dnd = this.dnd;\r\n        \tif (dnd.putSortable) {\r\n        \t\tdnd.putSortable._onDrop(evt)\r\n        \t}\r\n        \tif (dnd.draggable) {\r\n        \t\tdnd.draggable._onDragEnd(evt);\r\n        \t}\r\n        \tghoster.remove();\r\n        \tthis.destroy();\r\n\t\t},\r\n\r\n        _onTouchMove: function (/**TouchEvent*/evt, forAutoScroll) {\r\n            //dnd.log(\"_onTouchMove\",\"start\");\r\n            var dnd = this.dnd,\r\n            \tghostEl = ghoster.ghostEl,\r\n            \tdraggable = dnd.draggable,\r\n            \tdragEl = draggable.dragEl,\r\n            \ttapEvt = dnd.tapEvt;\r\n            if (tapEvt) {\r\n                var options =  draggable.options,\r\n                    fallbackTolerance = options.fallbackTolerance,\r\n                    fallbackOffset = options.fallbackOffset,\r\n                    touch = evt.touches ? evt.touches[0] : evt,\r\n                    matrix = ghostEl && transforms.matrix(ghostEl),\r\n                    scaleX = ghostEl && matrix && matrix.a,\r\n                    scaleY = ghostEl && matrix && matrix.d,\r\n                    relativeScrollOffset = ghoster.getRelativeScrollOffset(),\r\n                    dx = ((touch.clientX - tapEvt.clientX)\r\n                            + fallbackOffset.x) / (scaleX || 1)\r\n                            + (relativeScrollOffset ? (relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0]) : 0) / (scaleX || 1),\r\n                    dy = ((touch.clientY - tapEvt.clientY)\r\n                            + fallbackOffset.y) / (scaleY || 1)\r\n                            + (relativeScrollOffset ? (relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1]) : 0) / (scaleY || 1),\r\n                    translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';\r\n\r\n                // only set the status to dragging, when we are actually dragging\r\n                if (!dnd.active && !dnd.awaitingDragStarted) {\r\n                    if (fallbackTolerance &&\r\n                        Math.min( Math.abs(touch.clientX - draggable._lastX),  Math.abs(touch.clientY - draggable._lastY)) < fallbackTolerance\r\n                    ) {\r\n                        return;\r\n                    }\r\n                    draggable._onDragStart(evt, true);\r\n\r\n                    ghoster._appendGhost(dragEl,document.body,draggable.options);\r\n\r\n                \tdnd.ignoreNextClick = true;\r\n                \tthis._loopId = setInterval(this._emulateDragOver.bind(this), 50);\r\n\r\n                }\r\n\r\n                !forAutoScroll && this._handleAutoScroll(touch, true);\r\n\r\n                ///moved = true;\r\n                dnd.touchEvt = touch;\r\n\r\n                if (ghostEl) {\r\n                    //styler.css(ghostEl, 'webkitTransform', translate3d);\r\n                    //styler.css(ghostEl, 'mozTransform', translate3d);\r\n                    //styler.css(ghostEl, 'msTransform', translate3d);\r\n                    styler.css(ghostEl, 'transform', translate3d);\r\n\r\n                }\r\n\r\n                //evt.cancelable && evt.preventDefault();\r\n                evt.preventDefault()\r\n            }\r\n        },\r\n\r\n\t\t_emulateDragOver: function (forAutoScroll) {\r\n\t\t\tvar dnd = this.dnd,\r\n\t\t\t\tdragEl = dnd.draggable.dragEl,\r\n\t\t\t\ttouchEvt = dnd.touchEvt;\r\n\r\n\t\t\tif (touchEvt) {\r\n\t\t\t\tif (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY && !forAutoScroll) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthis._lastX = touchEvt.clientX;\r\n\t\t\t\tthis._lastY = touchEvt.clientY;\r\n\r\n\t\t\t\t//_hideGhostForTarget();\r\n\r\n\t\t\t\tvar target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\r\n\t\t\t\tvar parent = target;\r\n\r\n\t\t\t\twhile (target && target.shadowRoot) {\r\n\t\t\t\t\ttarget = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\r\n\t\t\t\t\tif (target === parent) break;\r\n\t\t\t\t\tparent = target;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (parent) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tif (parent[dnd.expando]) {\r\n\t\t\t\t\t\t\tvar inserted;\r\n\r\n\t\t\t\t\t\t\tinserted = parent[dnd.expando]._onDragOver({\r\n\t\t\t\t\t\t\t\tclientX: touchEvt.clientX,\r\n\t\t\t\t\t\t\t\tclientY: touchEvt.clientY,\r\n\t\t\t\t\t\t\t\ttarget: target,\r\n\t\t\t\t\t\t\t\trootEl: parent\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t//if (inserted && !this.options.dragoverBubble) {\r\n\t\t\t\t\t\t\tif (inserted) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttarget = parent; // store last element\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* jshint boss:true */\r\n\t\t\t\t\twhile (parent = parent.parentNode);\r\n\t\t\t\t}\r\n\t\t\t\tdragEl.parentNode[dnd.expando]._computeIsAligned(touchEvt);\r\n\r\n\t\t\t\t//_unhideGhostForTarget();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\r\n\t\t_handleAutoScroll: function(evt, fallback) {\r\n\t\t\tvar dnd = this.dnd;\r\n\r\n\t\t\tif (!dnd.draggable.dragEl || !dnd.draggable.options.scroll) return;\r\n\r\n\t\t\treturn autoscroll._handleAutoScroll(evt,dnd.draggable.options,fallback,dnd.expando);\r\n\t\t},\r\n\r\n\r\n\t\tdestroy : function() {\r\n\t\t\tthis.unlistenTo();\r\n        \tif (this._loopId) {\r\n        \t\tclearInterval(this._loopId);\r\n        \t}\r\n            autoscroll._nulling();\r\n            \r\n            autoscroll._clearAutoScrolls();\r\n            autoscroll._cancelThrottle();\r\n\r\n\t\t}\r\n\t});\r\n\r\n\treturn MousedDragDrop;\r\n});"]}