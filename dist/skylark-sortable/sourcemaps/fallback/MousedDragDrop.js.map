{"version":3,"sources":["fallback/MousedDragDrop.js"],"names":["define","langx","$","eventer","styler","finder","transforms","AutoScroll","ghoster","Emitter","inherit","_construct","dnd","this","$doc","document","listenTo","_onMouseMove","_onMouseUp","evt","putSortable","droppable","_onDrop","dragging","_onDragEnd","remove","destroy","ghostEl","draggable","dragEl","tapEvt","options","fallbackTolerance","fallbackOffset","matrix","scaleX","a","scaleY","d","relativeScrollOffset","getRelativeScrollOffset","dx","clientX","x","ghostRelativeParentInitialScroll","dy","clientY","y","translate3d","touches","_dragStarted","awaitingDragStarted","Math","min","abs","_lastX","_lastY","_onDragStart","_appendGhost","body","_loopId","setInterval","_emulateDragOver","bind","_handleAutoScroll","touchEvt","css","preventDefault","forAutoScroll","target","elementFromPoint","parent","shadowRoot","expando","_onDragOver","rootEl","parentNode","fallback","active","scroll","pointerElemChangedInterval","lastPointerElemX","lastPointerElemY","clearInterval","ogElemScroller","newElem","scrollableParent","autoscroller","handle","unlistenTo"],"mappings":"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","file":"../../fallback/MousedDragDrop.js","sourcesContent":["define([\n\t\"skylark-langx/langx\",\n\t\"skylark-domx-query\",\n\t\"skylark-domx-eventer\",\n\t\"skylark-domx-styler\",\n\t\"skylark-domx-finder\",\n\t\"skylark-domx-transforms\",\n\t\"skylark-domx-plugins-scrolls/auto-scroll\",\n\t\"./ghoster\"\n],function(\n\tlangx,\n\t$,\n\teventer,\n\tstyler,\n\tfinder,\n\ttransforms,\n\tAutoScroll,\n\tghoster\n){\n  'use strict';\n\n\n\tvar MousedDragDrop = langx.Emitter.inherit({\n\t\t_construct : function(dnd) {\n\t\t\tthis.dnd = dnd;\n\n\t\t\tvar $doc = $(document);\n\n\t\t\tthis.listenTo($doc,\"mousemove\",this._onMouseMove);\n\t\t\tthis.listenTo($doc,\"mouseup\",this._onMouseUp);\n\n\t\t},\n\n\t\t_onMouseUp : function(evt) {\n\t\t\tvar dnd = this.dnd;\n        \tif (dnd.putSortable) {\n        \t\tdnd.putSortable.droppable._onDrop(evt)\n        \t}\n        \tif (dnd.dragging) {\n        \t\tdnd.dragging._onDragEnd(evt);\n        \t}\n        \tghoster.remove();\n        \tthis.destroy();\n\t\t},\n\n        _onMouseMove: function (/**TouchEvent*/evt) {\n            //dnd.log(\"_onMouseMove\",\"start\");\n            var dnd = this.dnd,\n            \tghostEl = ghoster.ghostEl,\n            \tdraggable = dnd.dragging,\n            \tdragEl = dnd.dragEl,\n            \ttapEvt = dnd.tapEvt;\n            if (tapEvt) {\n                var options =  draggable.options,\n                    fallbackTolerance = options.fallbackTolerance,\n                    fallbackOffset = options.fallbackOffset,\n                    matrix = ghostEl && transforms.matrix(ghostEl),\n                    scaleX = ghostEl && matrix && matrix.a,\n                    scaleY = ghostEl && matrix && matrix.d,\n                    relativeScrollOffset = ghoster.getRelativeScrollOffset(),\n                    dx = ((evt.clientX - tapEvt.clientX)\n                            + fallbackOffset.x) / (scaleX || 1)\n                            + (relativeScrollOffset ? (relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0]) : 0) / (scaleX || 1),\n                    dy = ((evt.clientY - tapEvt.clientY)\n                            + fallbackOffset.y) / (scaleY || 1)\n                            + (relativeScrollOffset ? (relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1]) : 0) / (scaleY || 1),\n                    translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';\n\n                // only set the status to dragging, when we are actually dragging\n                if (!this._dragStarted && !dnd.awaitingDragStarted) {\n                    if (fallbackTolerance &&\n                        Math.min( Math.abs(evt.clientX - draggable._lastX),  Math.abs(evt.clientY - draggable._lastY)) < fallbackTolerance\n                    ) {\n                        return;\n                    }\n                    draggable._onDragStart(evt, true);\n\n                    ghoster._appendGhost(dragEl,document.body,draggable.options);\n\n                \t///dnd.ignoreNextClick = true;\n\n                \tthis._dragStarted = true;\n                \tthis._loopId = setInterval(this._emulateDragOver.bind(this), 50);\n\n                }\n\n                this._handleAutoScroll(evt, true);\n\n                ///moved = true;\n                ///dnd.touchEvt = touch;\n                this.touchEvt = evt;\n\n                if (ghostEl) {\n                    styler.css(ghostEl, 'transform', translate3d);\n\n                }\n\n                //evt.cancelable && evt.preventDefault();\n                evt.preventDefault()\n            }\n        },\n\n\t\t_emulateDragOver: function (forAutoScroll) {\n\t\t\tvar dnd = this.dnd,\n\t\t\t\tdragEl = dnd.dragEl,\n\t\t\t\t///touchEvt = dnd.touchEvt;\n\t\t\t\ttouchEvt = this.touchEvt;\n\n\t\t\tif (touchEvt) {\n\t\t\t\tif (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY && !forAutoScroll) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis._lastX = touchEvt.clientX;\n\t\t\t\tthis._lastY = touchEvt.clientY;\n\n\t\t\t\t//_hideGhostForTarget();\n\n\t\t\t\tvar target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n\t\t\t\tvar parent = target;\n\n\t\t\t\twhile (target && target.shadowRoot) {\n\t\t\t\t\ttarget = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\n\t\t\t\t\tif (target === parent) break;\n\t\t\t\t\tparent = target;\n\t\t\t\t}\n\n\t\t\t\tif (parent) {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (parent[dnd.expando]) {\n\t\t\t\t\t\t\tvar inserted;\n\n\t\t\t\t\t\t\tinserted = parent[dnd.expando].droppable._onDragOver({\n\t\t\t\t\t\t\t\tclientX: touchEvt.clientX,\n\t\t\t\t\t\t\t\tclientY: touchEvt.clientY,\n\t\t\t\t\t\t\t\ttarget: target,\n\t\t\t\t\t\t\t\trootEl: parent\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t//if (inserted && !this.options.dragoverBubble) {\n\t\t\t\t\t\t\tif (inserted) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttarget = parent; // store last element\n\t\t\t\t\t}\n\t\t\t\t\t/* jshint boss:true */\n\t\t\t\t\twhile (parent = parent.parentNode);\n\t\t\t\t}\n\t\t\t\t///dragEl.parentNode[dnd.expando]._computeIsAligned(touchEvt);\n\n\t\t\t\t//_unhideGhostForTarget();\n\t\t\t}\n\t\t},\n\n\n\t\t_handleAutoScroll: function(evt, fallback) {\n\t\t\tvar dnd = this.dnd;\n\n\t\t\tif (!dnd.dragEl || !dnd.active.options.scroll) return;\n\n\t\t\t///return autoscroll._handleAutoScroll(evt,dnd.active.options,fallback,dnd.expando);\n\n\n\t\t\tvar x = evt.clientX,\n\t\t\t\ty = evt.clientY,\n\n\t\t\t\telem = document.elementFromPoint(x, y);\n\n\n\t\t\t// Listener for pointer element change\n\t\t\t////var ogElemScroller = finder.scrollableParent(elem, true);\n\t\t\tif (\n\t\t\t\t(\n\t\t\t\t\t!this.pointerElemChangedInterval ||\n\t\t\t\t\tx !== this.lastPointerElemX ||\n\t\t\t\t\ty !== this.lastPointerElemY\n\t\t\t\t)\n\t\t\t) {\n\n\t\t\t\tif (this.pointerElemChangedInterval){\n\t\t\t\t\tclearInterval(this.pointerElemChangedInterval);\t\n\t\t\t\t} \n\t\t\t\t// Detect for pointer elem change, emulating native DnD behaviour\n  \t\t\t    var ogElemScroller = null ;\n\t\t\t\tthis.pointerElemChangedInterval = setInterval(function() {\n\t\t\t\t\t// could also check if scroll direction on newElem changes due to parent autoscrolling\n\t\t\t\t\tvar newElem = finder.scrollableParent(document.elementFromPoint(x, y), true);\n\t\t\t\t\tif (newElem !== ogElemScroller) {\n\t\t\t\t\t\togElemScroller = newElem;\n\t\t\t\t\t\tif (this.autoscroller) {\n\t\t\t\t\t\t\tthis.autoscroller.destroy();\n\t\t\t\t\t\t\tthis.autoscroller = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.autoscroller = new AutoScroll(ogElemScroller,dnd.active.options);\n\t\t\t\t\t\tthis.autoscroller.handle(x,y);\n\t\t\t\t\t}\n\t\t\t\t}, 10);\n\t\t\t\tthis.lastPointerElemX = x;\n\t\t\t\tthis.lastPointerElemY = y;\n\t\t\t}\n    \t},\n\n\t\tdestroy : function() {\n\t\t\tthis.unlistenTo();\n        \tif (this._loopId) {\n        \t\tclearInterval(this._loopId);\n        \t}\n\n\t\t\tif (this.pointerElemChangedInterval){\n\t\t\t\tclearInterval(this.pointerElemChangedInterval);\t\n\t\t\t} \n\n            ///autoscroll._nulling();\n            \n            //autoscroll._clearAutoScrolls();\n            ///autoscroll._cancelThrottle();\n\n            if (this.autoscroller) {\n            \tthis.autoscroller.destroy();\n            \tthis.autoscroller = null;            \t\n            }\n\n            this._dragStarted = false;\n\t\t}\n\t});\n\n\treturn MousedDragDrop;\n});"]}