{"version":3,"sources":["dnd.js"],"names":["define","skylark","langx","isBrowser","isMobile","$","browser","noder","finder","geom","styler","eventer","transforms","scrollingElement","oriented","touch","autoscroll","ghoster","expando","Date","getTime","dnd","log","category","message","append","activeGroup","active","putSortable","sortables","dragEl","cloneEl","ignoreNextClick","awaitingDragStarted","touchEvt","prepare","draggable","this","nativeDraggable","on","document","_onTouchMove","evt","off","_onDrop","_onDragEnd","remove","start","event","ownerDocument","elm","nearestEmptyInsertDetectEvent","_handleAutoScroll","_checkAlignment","over","end","dropped","_nulling","touches","nearest","_detectNearestEmptySortable","clientX","clientY","i","target","rootEl","preventDefault","stopPropagation","_onDragOver","x","y","length","lastChild","ignoreHidden","excluding","ghostEl","rect","boundingRect","threshold","options","emptyInsertThreshold","insideHorizontally","left","right","insideVertically","top","bottom","parentNode","_computeIsAligned","_emulateDragOver","forAutoScroll","_lastX","_lastY","elementFromPoint","parent","shadowRoot","_onMove","fromEl","toEl","dragRect","targetEl","targetRect","originalEvt","willInsertAfter","retVal","sortable","onMoveFn","onMove","create","to","from","dragged","draggedRect","related","relatedRect","originalEvent","dispatchEvent","call","_dispatchEvent","name","startIndex","newIndex","startDraggableIndex","newDraggableIndex","onName","charAt","toUpperCase","substr","item","clone","oldIndex","oldDraggableIndex","pullMode","lastPutMode","undefined","_disableDraggable","el","fallback","scroll","tapEvt","fallbackTolerance","fallbackOffset","matrix","scaleX","a","scaleY","d","relativeScrollOffset","getRelativeScrollOffset","dx","ghostRelativeParentInitialScroll","dy","translate3d","Math","min","abs","_onDragStart","css","parentEl","nextEl","scrollEl","scrollParentEl","autoScrolls"],"mappings":"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","file":"../dnd.js","sourcesContent":["define([\r\n\t\"skylark-langx/skylark\",\r\n\t\"skylark-langx/langx\",\r\n\t\"skylark-langx-hoster/isBrowser\",\r\n\t\"skylark-langx-hoster/isMobile\",\r\n\t\"skylark-domx-query\",\r\n\t\"skylark-domx-browser\",\r\n\t\"skylark-domx-noder\",\r\n\t\"skylark-domx-finder\",\r\n\t\"skylark-domx-geom\",\r\n\t\"skylark-domx-styler\",\r\n\t\"skylark-domx-eventer\",\r\n\t\"skylark-domx-transforms\",\r\n\t\"skylark-domx-scrolls/scrollingElement\",\r\n\t\"skylark-domx-layouts/oriented\",\r\n\t\"skylark-devices-points/touch\",\r\n\t\"./autoscroll\",\r\n\t\"./ghoster\"\r\n],function(\r\n\tskylark,\r\n\tlangx,\r\n\tisBrowser,\r\n\tisMobile,\r\n\t$,\r\n\tbrowser,\r\n\tnoder,\r\n\tfinder,\r\n\tgeom,\r\n\tstyler,\r\n\teventer,\r\n\ttransforms,\r\n\tscrollingElement,\r\n\toriented,\r\n\ttouch,\r\n\tautoscroll,\r\n\tghoster\r\n){\r\n    'use strict';\r\n\r\n\r\n\tvar expando = 'Sortable' + (new Date).getTime();\r\n\r\n\r\n\tvar dnd = {\r\n\t\tlog : function log(category,message) {\r\n\t\t\t$(\"#console\").append(\"<div>\"+category+\":\"+message+\"</div>\");\t\r\n\t\t},\r\n\r\n\t\texpando,\r\n\r\n\t\tactiveGroup : null,\r\n\t\tactive : null,\r\n\t\tputSortable : null,\r\n\t\tsortables : [],\r\n\r\n\r\n\t\tdragEl : null,\r\n\t\tcloneEl : null,\r\n\r\n\t\tignoreNextClick : false,\r\n        awaitingDragStarted : false,\r\n\r\n\r\n\t\ttouchEvt : null,\r\n\r\n        prepare: function(draggable) {\r\n        \tthis.draggable = draggable;\r\n            if (!draggable.nativeDraggable) {\r\n                eventer.on(document, 'mousemove', this._onTouchMove);\r\n                eventer.on(document, 'mouseup',function(evt){\r\n                \teventer.off(document,'mousemove', this._onTouchMove);\r\n                \tif (dnd.putSortable) {\r\n                \t\tdnd.putSortable._onDrop(evt)\r\n                \t}\r\n                \tif (dnd.draggable) {\r\n                \t\tdnd.draggable._onDragEnd(evt);\r\n                \t}\r\n                \tghoster.remove();\r\n                })\r\n            }\r\n\r\n\t\t},\r\n\r\n        start: function(draggable, event) {\r\n        \tthis.draggable = draggable;\r\n\r\n\r\n\t\t\tvar el = draggable.elm(),\r\n\t\t\t\townerDocument = el.ownerDocument;\r\n\r\n\r\n\t\t\teventer.on(ownerDocument, 'dragover', this.nearestEmptyInsertDetectEvent);\r\n\t\t\teventer.on(ownerDocument, 'mousemove', this.nearestEmptyInsertDetectEvent);\r\n\t\t\t///eventer.on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\r\n\r\n\t\t\tif (this.draggable.nativeDraggable) {\r\n                eventer.on(document, 'dragover', this._handleAutoScroll);\r\n                eventer.on(document, 'dragover', this._checkAlignment);\r\n            } else {\r\n                eventer.on(document, 'mousemove', this._onTouchMove);\r\n            }\r\n        },\r\n\r\n        over : function(evt) {\r\n\t\t\tthis._handleAutoScroll(evt);\r\n        },\r\n\r\n        end: function(dropped) {\r\n\t  \t\teventer.off(document, 'dragover', this.nearestEmptyInsertDetectEvent);\r\n\t  \t\teventer.off(document, 'mousemove', this.nearestEmptyInsertDetectEvent);\r\n\t\r\n\t\t\tif (this.draggable.nativeDraggable) {\r\n\t\t\t\teventer.off(document, 'dragover', this._handleAutoScroll);\r\n\t\t\t\teventer.off(document, 'dragover', this._checkAlignment);\r\n\t\t\t} else {\r\n\t\t        // Unbind events\r\n\t            eventer.off(document, 'mousemove', this._onTouchMove);\r\n\r\n\t\t\t}\r\n\r\n        \tthis.draggable = null;\r\n\r\n        \tthis._nulling();\r\n \t\t},\r\n\r\n\t\tnearestEmptyInsertDetectEvent :function (evt) {\r\n\t\t\tif (dnd.dragEl) {\r\n\t\t\t\tevt = evt.touches ? evt.touches[0] : evt;\r\n\t\t\t\tvar nearest = dnd._detectNearestEmptySortable(evt.clientX, evt.clientY);\r\n\r\n\t\t\t\tif (nearest) {\r\n\t\t\t\t\t// Create imitation event\r\n\t\t\t\t\tvar event = {};\r\n\t\t\t\t\tfor (var i in evt) {\r\n\t\t\t\t\t\tevent[i] = evt[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tevent.target = event.rootEl = nearest;\r\n\t\t\t\t\tevent.preventDefault = void 0;\r\n\t\t\t\t\tevent.stopPropagation = void 0;\r\n\t\t\t\t\tnearest[expando]._onDragOver(event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, \r\n\r\n\t\t/**\r\n\t\t * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\r\n\t\t * @param  {Number} x      X position\r\n\t\t * @param  {Number} y      Y position\r\n\t\t * @return {HTMLElement}   Element of the first found nearest Sortable\r\n\t\t */\r\n\t\t_detectNearestEmptySortable : function(x, y) {\r\n\t\t\tvar sortables = this.sortables;\r\n\r\n\t\t\tfor (var i = 0; i < sortables.length; i++) {\r\n\t\t\t\tif (finder.lastChild(sortables[i],{ignoreHidden : true,excluding : [this.ghostEl]})) continue;\r\n\r\n\t\t\t\tvar rect = geom.boundingRect(sortables[i]),\r\n\t\t\t\t\tthreshold = sortables[i][expando].options.emptyInsertThreshold,\r\n\t\t\t\t\tinsideHorizontally = x >= (rect.left - threshold) && x <= (rect.right + threshold),\r\n\t\t\t\t\tinsideVertically = y >= (rect.top - threshold) && y <= (rect.bottom + threshold);\r\n\r\n\t\t\t\tif (threshold && insideHorizontally && insideVertically) {\r\n\t\t\t\t\treturn sortables[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_checkAlignment : function(evt) {\r\n\t\t\tif (!this.dragEl || !this.dragEl.parentNode) return;\r\n\t\t\tthis.dragEl.parentNode[expando] && this.dragEl.parentNode[expando]._computeIsAligned(evt);\r\n\t\t},\r\n\r\n\t\t_emulateDragOver: function (forAutoScroll) {\r\n\t\t\tvar dragEl = this.dragEl,\r\n\t\t\t\ttouchEvt = this.touchEvt;\r\n\r\n\t\t\tif (touchEvt) {\r\n\t\t\t\tif (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY && !forAutoScroll) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthis._lastX = touchEvt.clientX;\r\n\t\t\t\tthis._lastY = touchEvt.clientY;\r\n\r\n\t\t\t\t//_hideGhostForTarget();\r\n\r\n\t\t\t\tvar target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\r\n\t\t\t\tvar parent = target;\r\n\r\n\t\t\t\twhile (target && target.shadowRoot) {\r\n\t\t\t\t\ttarget = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\r\n\t\t\t\t\tif (target === parent) break;\r\n\t\t\t\t\tparent = target;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (parent) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tif (parent[expando]) {\r\n\t\t\t\t\t\t\tvar inserted;\r\n\r\n\t\t\t\t\t\t\tinserted = parent[expando]._onDragOver({\r\n\t\t\t\t\t\t\t\tclientX: touchEvt.clientX,\r\n\t\t\t\t\t\t\t\tclientY: touchEvt.clientY,\r\n\t\t\t\t\t\t\t\ttarget: target,\r\n\t\t\t\t\t\t\t\trootEl: parent\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t//if (inserted && !this.options.dragoverBubble) {\r\n\t\t\t\t\t\t\tif (inserted) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttarget = parent; // store last element\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* jshint boss:true */\r\n\t\t\t\t\twhile (parent = parent.parentNode);\r\n\t\t\t\t}\r\n\t\t\t\tdragEl.parentNode[expando]._computeIsAligned(touchEvt);\r\n\r\n\t\t\t\t//_unhideGhostForTarget();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onMove : function (fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {\r\n\t\t\tvar evt,\r\n\t\t\t\tsortable = fromEl[expando],\r\n\t\t\t\tonMoveFn = sortable.options.onMove,\r\n\t\t\t\tretVal;\r\n\r\n\t\t\tevt = eventer.create(\"move\",{\r\n\t\t\t\tto : toEl,\r\n\t\t\t\tfrom : fromEl,\r\n\t\t\t\tdragged : dragEl,\r\n\t\t\t\tdraggedRect: dragRect,\r\n\t\t\t\trelated : targetEl || toEl,\r\n\t\t\t\trelatedRect : targetRect || geom.boundingRect(toEl),\r\n\t\t\t\twillInsertAfter : willInsertAfter,\r\n\t\t\t\toriginalEvent : originalEvt\r\n\t\t\t});\r\n\r\n\t\t\tfromEl.dispatchEvent(evt);\r\n\r\n\t\t\tif (onMoveFn) {\r\n\t\t\t\tretVal = onMoveFn.call(sortable, evt, originalEvt);\r\n\t\t\t}\r\n\r\n\t\t\treturn retVal;\r\n\t\t},\r\n\r\n\t\t_dispatchEvent : function (\r\n\t\t\tsortable, rootEl, name,\r\n\t\t\ttargetEl, toEl, fromEl,\r\n\t\t\tstartIndex, newIndex,\r\n\t\t\tstartDraggableIndex, newDraggableIndex,\r\n\t\t\toriginalEvt\r\n\t\t) {\r\n\t\t\tsortable = (sortable || rootEl[expando]);\r\n\t\t\tvar evt,\r\n\t\t\t\toptions = sortable.options,\r\n\t\t\t\tonName = 'on' + name.charAt(0).toUpperCase() + name.substr(1),\r\n\t\t\t\tputSortable = this.putSortable;\r\n\r\n\t\t\tevt = eventer.create(name,{\r\n\t\t\t\tto : toEl || rootEl,\r\n\t\t\t\tfrom : fromEl || rootEl,\r\n\t\t\t\titem : targetEl || rootEl,\r\n\t\t\t\tclone : this.cloneEl,\r\n\t\t\t\toldIndex : startIndex,\r\n\t\t\t\tnewIndex : newIndex,\r\n\t\t\t\toldDraggableIndex : startDraggableIndex,\r\n\t\t\t\tnewDraggableIndex : newDraggableIndex,\r\n\t\t\t\toriginalEvent : originalEvt,\r\n\t\t\t\tpullMode : putSortable ? putSortable.lastPutMode : undefined\r\n\t\t\t});\r\n\t\t\tif (rootEl) {\r\n\t\t\t\trootEl.dispatchEvent(evt);\r\n\t\t\t}\r\n\r\n\t\t\tif (options[onName]) {\r\n\t\t\t\toptions[onName].call(sortable, evt);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_disableDraggable : function (el) {\r\n\t\t\tel.draggable = false;\r\n\t\t},\r\n\r\n\t\t_handleAutoScroll: function(evt, fallback) {\r\n\r\n\t\t\tif (!dnd.dragEl || !dnd.draggable.options.scroll) return;\r\n\r\n\t\t\treturn autoscroll._handleAutoScroll(evt,dnd.draggable.options,fallback);\r\n\t\t},\r\n\r\n        _onTouchMove: function (/**TouchEvent*/evt, forAutoScroll) {\r\n            //dnd.log(\"_onTouchMove\",\"start\");\r\n            var ghostEl = ghoster.ghostEl,\r\n            \tdraggable = dnd.draggable,\r\n            \ttapEvt = dnd.tapEvt;\r\n            if (tapEvt) {\r\n                var options =  draggable.options,\r\n                    fallbackTolerance = options.fallbackTolerance,\r\n                    fallbackOffset = options.fallbackOffset,\r\n                    touch = evt.touches ? evt.touches[0] : evt,\r\n                    matrix = ghostEl && transforms.matrix(ghostEl),\r\n                    scaleX = ghostEl && matrix && matrix.a,\r\n                    scaleY = ghostEl && matrix && matrix.d,\r\n                    relativeScrollOffset = ghoster.getRelativeScrollOffset(),\r\n                    dx = ((touch.clientX - tapEvt.clientX)\r\n                            + fallbackOffset.x) / (scaleX || 1)\r\n                            + (relativeScrollOffset ? (relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0]) : 0) / (scaleX || 1),\r\n                    dy = ((touch.clientY - tapEvt.clientY)\r\n                            + fallbackOffset.y) / (scaleY || 1)\r\n                            + (relativeScrollOffset ? (relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1]) : 0) / (scaleY || 1),\r\n                    translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';\r\n\r\n                // only set the status to dragging, when we are actually dragging\r\n                if (!dnd.active && !dnd.awaitingDragStarted) {\r\n                    if (fallbackTolerance &&\r\n                        Math.min( Math.abs(touch.clientX - draggable._lastX),  Math.abs(touch.clientY - draggable._lastY)) < fallbackTolerance\r\n                    ) {\r\n                        return;\r\n                    }\r\n                    draggable._onDragStart(evt, true);\r\n                }\r\n\r\n                !forAutoScroll && dnd._handleAutoScroll(touch, true);\r\n\r\n                ///moved = true;\r\n                dnd.touchEvt = touch;\r\n\r\n                if (ghostEl) {\r\n                    //styler.css(ghostEl, 'webkitTransform', translate3d);\r\n                    //styler.css(ghostEl, 'mozTransform', translate3d);\r\n                    //styler.css(ghostEl, 'msTransform', translate3d);\r\n                    styler.css(ghostEl, 'transform', translate3d);\r\n\r\n                }\r\n\r\n                //evt.cancelable && evt.preventDefault();\r\n                evt.preventDefault()\r\n            }\r\n        },\r\n\r\n\t\t_nulling: function() {\r\n\r\n\t\t\tdnd.rootEl =\r\n\t\t\tdnd.dragEl =\r\n\t\t\tdnd.parentEl =\r\n\t\t\t//ghoster.ghostEl =\r\n\t\t\tdnd.nextEl =\r\n\t\t\tdnd.cloneEl =\r\n\t\t\t///lastDownEl =\r\n\r\n\t\t\tautoscroll.scrollEl =\r\n\t\t\tautoscroll.scrollParentEl =\r\n\t\t\tautoscroll.autoScrolls.length =\r\n\r\n\r\n\t\t\tdnd.tapEvt =\r\n\t\t\tdnd.touchEvt =\r\n\r\n\t\t\tdnd.oldIndex =\r\n\r\n\t\t\tdnd.putSortable =\r\n\t\t\tdnd.activeGroup =\r\n\t\t\tdnd.active = null;\r\n\r\n\t\t},\r\n\r\n\r\n\t};\r\n\r\n\r\n\treturn dnd;\r\n\t\r\n});"]}