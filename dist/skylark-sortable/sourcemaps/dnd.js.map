{"version":3,"sources":["dnd.js"],"names":["define","skylark","langx","isBrowser","isMobile","$","browser","noder","finder","geom","styler","eventer","transforms","scrollingElement","oriented","touch","autoscroll","ghoster","expando","Date","getTime","dnd","log","category","message","append","activeGroup","active","putSortable","sortables","dragEl","cloneEl","ignoreNextClick","awaitingDragStarted","touchEvt","prepare","draggable","this","nativeDraggable","on","document","_onTouchMove","evt","off","_onDrop","_onDragEnd","remove","_loopId","clearInterval","start","event","ownerDocument","elm","nearestEmptyInsertDetectEvent","_handleAutoScroll","_checkAlignment","over","end","dropped","_nulling","touches","nearest","_detectNearestEmptySortable","clientX","clientY","i","target","rootEl","preventDefault","stopPropagation","_onDragOver","x","y","length","lastChild","ignoreHidden","excluding","ghostEl","rect","boundingRect","threshold","options","emptyInsertThreshold","insideHorizontally","left","right","insideVertically","top","bottom","parentNode","_computeIsAligned","_emulateDragOver","forAutoScroll","_lastX","_lastY","elementFromPoint","parent","shadowRoot","_onMove","fromEl","toEl","dragRect","targetEl","targetRect","originalEvt","willInsertAfter","retVal","sortable","onMoveFn","onMove","create","to","from","dragged","draggedRect","related","relatedRect","originalEvent","dispatchEvent","call","_dispatchEvent","name","startIndex","newIndex","startDraggableIndex","newDraggableIndex","onName","charAt","toUpperCase","substr","item","clone","oldIndex","oldDraggableIndex","pullMode","lastPutMode","undefined","_disableDraggable","el","fallback","scroll","tapEvt","fallbackTolerance","fallbackOffset","matrix","scaleX","a","scaleY","d","relativeScrollOffset","getRelativeScrollOffset","dx","ghostRelativeParentInitialScroll","dy","translate3d","Math","min","abs","_onDragStart","setInterval","bind","css","parentEl","nextEl","scrollEl","scrollParentEl","autoScrolls"],"mappings":"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","file":"../dnd.js","sourcesContent":["define([\r\n\t\"skylark-langx/skylark\",\r\n\t\"skylark-langx/langx\",\r\n\t\"skylark-langx-hoster/isBrowser\",\r\n\t\"skylark-langx-hoster/isMobile\",\r\n\t\"skylark-domx-query\",\r\n\t\"skylark-domx-browser\",\r\n\t\"skylark-domx-noder\",\r\n\t\"skylark-domx-finder\",\r\n\t\"skylark-domx-geom\",\r\n\t\"skylark-domx-styler\",\r\n\t\"skylark-domx-eventer\",\r\n\t\"skylark-domx-transforms\",\r\n\t\"skylark-domx-scrolls/scrollingElement\",\r\n\t\"skylark-domx-layouts/oriented\",\r\n\t\"skylark-devices-points/touch\",\r\n\t\"./autoscroll\",\r\n\t\"./ghoster\"\r\n],function(\r\n\tskylark,\r\n\tlangx,\r\n\tisBrowser,\r\n\tisMobile,\r\n\t$,\r\n\tbrowser,\r\n\tnoder,\r\n\tfinder,\r\n\tgeom,\r\n\tstyler,\r\n\teventer,\r\n\ttransforms,\r\n\tscrollingElement,\r\n\toriented,\r\n\ttouch,\r\n\tautoscroll,\r\n\tghoster\r\n){\r\n    'use strict';\r\n\r\n\r\n\tvar expando = 'Sortable' + (new Date).getTime();\r\n\r\n\r\n\tvar dnd = {\r\n\t\tlog : function log(category,message) {\r\n\t\t\t$(\"#console\").append(\"<div>\"+category+\":\"+message+\"</div>\");\t\r\n\t\t},\r\n\r\n\t\texpando,\r\n\r\n\t\tactiveGroup : null,\r\n\t\tactive : null,\r\n\t\tputSortable : null,\r\n\t\tsortables : [],\r\n\r\n\r\n\t\tdragEl : null,\r\n\t\tcloneEl : null,\r\n\r\n\t\tignoreNextClick : false,\r\n        awaitingDragStarted : false,\r\n\r\n\r\n\t\ttouchEvt : null,\r\n\r\n        prepare: function(draggable) {\r\n        \tthis.draggable = draggable;\r\n            if (!draggable.nativeDraggable) {\r\n                eventer.on(document, 'mousemove', this._onTouchMove);\r\n                eventer.on(document, 'mouseup',function(evt){\r\n                \teventer.off(document,'mousemove', this._onTouchMove);\r\n                \tif (dnd.putSortable) {\r\n                \t\tdnd.putSortable._onDrop(evt)\r\n                \t}\r\n                \tif (dnd.draggable) {\r\n                \t\tdnd.draggable._onDragEnd(evt);\r\n                \t}\r\n                \tghoster.remove();\r\n                \tif (dnd._loopId) {\r\n                \t\tclearInterval(dnd._loopId);\r\n                \t}\r\n                \tdnd._loopId = null\r\n                })\r\n            }\r\n\r\n\t\t},\r\n\r\n        start: function(draggable, event) {\r\n        \tthis.draggable = draggable;\r\n\r\n\r\n\t\t\tvar el = draggable.elm(),\r\n\t\t\t\townerDocument = el.ownerDocument;\r\n\r\n\r\n\t\t\teventer.on(ownerDocument, 'dragover', this.nearestEmptyInsertDetectEvent);\r\n\t\t\teventer.on(ownerDocument, 'mousemove', this.nearestEmptyInsertDetectEvent);\r\n\t\t\t///eventer.on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);\r\n\r\n\t\t\tif (this.draggable.nativeDraggable) {\r\n                eventer.on(document, 'dragover', this._handleAutoScroll);\r\n                eventer.on(document, 'dragover', this._checkAlignment);\r\n            } else {\r\n                eventer.on(document, 'mousemove', this._onTouchMove);\r\n            }\r\n        },\r\n\r\n        over : function(evt) {\r\n\t\t\tthis._handleAutoScroll(evt);\r\n        },\r\n\r\n        end: function(dropped) {\r\n\t  \t\teventer.off(document, 'dragover', this.nearestEmptyInsertDetectEvent);\r\n\t  \t\teventer.off(document, 'mousemove', this.nearestEmptyInsertDetectEvent);\r\n\t\r\n\t\t\tif (this.draggable.nativeDraggable) {\r\n\t\t\t\teventer.off(document, 'dragover', this._handleAutoScroll);\r\n\t\t\t\teventer.off(document, 'dragover', this._checkAlignment);\r\n\t\t\t} else {\r\n\t\t        // Unbind events\r\n\t            eventer.off(document, 'mousemove', this._onTouchMove);\r\n\r\n\t\t\t}\r\n\r\n        \tthis.draggable = null;\r\n\r\n        \tthis._nulling();\r\n \t\t},\r\n\r\n\t\tnearestEmptyInsertDetectEvent :function (evt) {\r\n\t\t\tif (dnd.dragEl) {\r\n\t\t\t\tevt = evt.touches ? evt.touches[0] : evt;\r\n\t\t\t\tvar nearest = dnd._detectNearestEmptySortable(evt.clientX, evt.clientY);\r\n\r\n\t\t\t\tif (nearest) {\r\n\t\t\t\t\t// Create imitation event\r\n\t\t\t\t\tvar event = {};\r\n\t\t\t\t\tfor (var i in evt) {\r\n\t\t\t\t\t\tevent[i] = evt[i];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tevent.target = event.rootEl = nearest;\r\n\t\t\t\t\tevent.preventDefault = void 0;\r\n\t\t\t\t\tevent.stopPropagation = void 0;\r\n\t\t\t\t\tnearest[expando]._onDragOver(event);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}, \r\n\r\n\t\t/**\r\n\t\t * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\r\n\t\t * @param  {Number} x      X position\r\n\t\t * @param  {Number} y      Y position\r\n\t\t * @return {HTMLElement}   Element of the first found nearest Sortable\r\n\t\t */\r\n\t\t_detectNearestEmptySortable : function(x, y) {\r\n\t\t\tvar sortables = this.sortables;\r\n\r\n\t\t\tfor (var i = 0; i < sortables.length; i++) {\r\n\t\t\t\tif (finder.lastChild(sortables[i],{ignoreHidden : true,excluding : [this.ghostEl]})) continue;\r\n\r\n\t\t\t\tvar rect = geom.boundingRect(sortables[i]),\r\n\t\t\t\t\tthreshold = sortables[i][expando].options.emptyInsertThreshold,\r\n\t\t\t\t\tinsideHorizontally = x >= (rect.left - threshold) && x <= (rect.right + threshold),\r\n\t\t\t\t\tinsideVertically = y >= (rect.top - threshold) && y <= (rect.bottom + threshold);\r\n\r\n\t\t\t\tif (threshold && insideHorizontally && insideVertically) {\r\n\t\t\t\t\treturn sortables[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_checkAlignment : function(evt) {\r\n\t\t\tif (!this.dragEl || !this.dragEl.parentNode) return;\r\n\t\t\tthis.dragEl.parentNode[expando] && this.dragEl.parentNode[expando]._computeIsAligned(evt);\r\n\t\t},\r\n\r\n\t\t_emulateDragOver: function (forAutoScroll) {\r\n\t\t\tvar dragEl = this.dragEl,\r\n\t\t\t\ttouchEvt = this.touchEvt;\r\n\r\n\t\t\tif (touchEvt) {\r\n\t\t\t\tif (this._lastX === touchEvt.clientX && this._lastY === touchEvt.clientY && !forAutoScroll) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tthis._lastX = touchEvt.clientX;\r\n\t\t\t\tthis._lastY = touchEvt.clientY;\r\n\r\n\t\t\t\t//_hideGhostForTarget();\r\n\r\n\t\t\t\tvar target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\r\n\t\t\t\tvar parent = target;\r\n\r\n\t\t\t\twhile (target && target.shadowRoot) {\r\n\t\t\t\t\ttarget = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);\r\n\t\t\t\t\tif (target === parent) break;\r\n\t\t\t\t\tparent = target;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (parent) {\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tif (parent[expando]) {\r\n\t\t\t\t\t\t\tvar inserted;\r\n\r\n\t\t\t\t\t\t\tinserted = parent[expando]._onDragOver({\r\n\t\t\t\t\t\t\t\tclientX: touchEvt.clientX,\r\n\t\t\t\t\t\t\t\tclientY: touchEvt.clientY,\r\n\t\t\t\t\t\t\t\ttarget: target,\r\n\t\t\t\t\t\t\t\trootEl: parent\r\n\t\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\t\t//if (inserted && !this.options.dragoverBubble) {\r\n\t\t\t\t\t\t\tif (inserted) {\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\ttarget = parent; // store last element\r\n\t\t\t\t\t}\r\n\t\t\t\t\t/* jshint boss:true */\r\n\t\t\t\t\twhile (parent = parent.parentNode);\r\n\t\t\t\t}\r\n\t\t\t\tdragEl.parentNode[expando]._computeIsAligned(touchEvt);\r\n\r\n\t\t\t\t//_unhideGhostForTarget();\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_onMove : function (fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {\r\n\t\t\tvar evt,\r\n\t\t\t\tsortable = fromEl[expando],\r\n\t\t\t\tonMoveFn = sortable.options.onMove,\r\n\t\t\t\tretVal;\r\n\r\n\t\t\tevt = eventer.create(\"move\",{\r\n\t\t\t\tto : toEl,\r\n\t\t\t\tfrom : fromEl,\r\n\t\t\t\tdragged : dragEl,\r\n\t\t\t\tdraggedRect: dragRect,\r\n\t\t\t\trelated : targetEl || toEl,\r\n\t\t\t\trelatedRect : targetRect || geom.boundingRect(toEl),\r\n\t\t\t\twillInsertAfter : willInsertAfter,\r\n\t\t\t\toriginalEvent : originalEvt\r\n\t\t\t});\r\n\r\n\t\t\tfromEl.dispatchEvent(evt);\r\n\r\n\t\t\tif (onMoveFn) {\r\n\t\t\t\tretVal = onMoveFn.call(sortable, evt, originalEvt);\r\n\t\t\t}\r\n\r\n\t\t\treturn retVal;\r\n\t\t},\r\n\r\n\t\t_dispatchEvent : function (\r\n\t\t\tsortable, rootEl, name,\r\n\t\t\ttargetEl, toEl, fromEl,\r\n\t\t\tstartIndex, newIndex,\r\n\t\t\tstartDraggableIndex, newDraggableIndex,\r\n\t\t\toriginalEvt\r\n\t\t) {\r\n\t\t\tsortable = (sortable || rootEl[expando]);\r\n\t\t\tvar evt,\r\n\t\t\t\toptions = sortable.options,\r\n\t\t\t\tonName = 'on' + name.charAt(0).toUpperCase() + name.substr(1),\r\n\t\t\t\tputSortable = this.putSortable;\r\n\r\n\t\t\tevt = eventer.create(name,{\r\n\t\t\t\tto : toEl || rootEl,\r\n\t\t\t\tfrom : fromEl || rootEl,\r\n\t\t\t\titem : targetEl || rootEl,\r\n\t\t\t\tclone : this.cloneEl,\r\n\t\t\t\toldIndex : startIndex,\r\n\t\t\t\tnewIndex : newIndex,\r\n\t\t\t\toldDraggableIndex : startDraggableIndex,\r\n\t\t\t\tnewDraggableIndex : newDraggableIndex,\r\n\t\t\t\toriginalEvent : originalEvt,\r\n\t\t\t\tpullMode : putSortable ? putSortable.lastPutMode : undefined\r\n\t\t\t});\r\n\t\t\tif (rootEl) {\r\n\t\t\t\trootEl.dispatchEvent(evt);\r\n\t\t\t}\r\n\r\n\t\t\tif (options[onName]) {\r\n\t\t\t\toptions[onName].call(sortable, evt);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t_disableDraggable : function (el) {\r\n\t\t\tel.draggable = false;\r\n\t\t},\r\n\r\n\t\t_handleAutoScroll: function(evt, fallback) {\r\n\r\n\t\t\tif (!dnd.dragEl || !dnd.draggable.options.scroll) return;\r\n\r\n\t\t\treturn autoscroll._handleAutoScroll(evt,dnd.draggable.options,fallback);\r\n\t\t},\r\n\r\n        _onTouchMove: function (/**TouchEvent*/evt, forAutoScroll) {\r\n            //dnd.log(\"_onTouchMove\",\"start\");\r\n            var ghostEl = ghoster.ghostEl,\r\n            \tdraggable = dnd.draggable,\r\n            \ttapEvt = dnd.tapEvt;\r\n            if (tapEvt) {\r\n                var options =  draggable.options,\r\n                    fallbackTolerance = options.fallbackTolerance,\r\n                    fallbackOffset = options.fallbackOffset,\r\n                    touch = evt.touches ? evt.touches[0] : evt,\r\n                    matrix = ghostEl && transforms.matrix(ghostEl),\r\n                    scaleX = ghostEl && matrix && matrix.a,\r\n                    scaleY = ghostEl && matrix && matrix.d,\r\n                    relativeScrollOffset = ghoster.getRelativeScrollOffset(),\r\n                    dx = ((touch.clientX - tapEvt.clientX)\r\n                            + fallbackOffset.x) / (scaleX || 1)\r\n                            + (relativeScrollOffset ? (relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0]) : 0) / (scaleX || 1),\r\n                    dy = ((touch.clientY - tapEvt.clientY)\r\n                            + fallbackOffset.y) / (scaleY || 1)\r\n                            + (relativeScrollOffset ? (relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1]) : 0) / (scaleY || 1),\r\n                    translate3d = evt.touches ? 'translate3d(' + dx + 'px,' + dy + 'px,0)' : 'translate(' + dx + 'px,' + dy + 'px)';\r\n\r\n                // only set the status to dragging, when we are actually dragging\r\n                if (!dnd.active && !dnd.awaitingDragStarted) {\r\n                    if (fallbackTolerance &&\r\n                        Math.min( Math.abs(touch.clientX - draggable._lastX),  Math.abs(touch.clientY - draggable._lastY)) < fallbackTolerance\r\n                    ) {\r\n                        return;\r\n                    }\r\n                    draggable._onDragStart(evt, true);\r\n                \tdnd.ignoreNextClick = true;\r\n                \tdnd._loopId = setInterval(dnd._emulateDragOver.bind(dnd), 50);\r\n\r\n                }\r\n\r\n                !forAutoScroll && dnd._handleAutoScroll(touch, true);\r\n\r\n                ///moved = true;\r\n                dnd.touchEvt = touch;\r\n\r\n                if (ghostEl) {\r\n                    //styler.css(ghostEl, 'webkitTransform', translate3d);\r\n                    //styler.css(ghostEl, 'mozTransform', translate3d);\r\n                    //styler.css(ghostEl, 'msTransform', translate3d);\r\n                    styler.css(ghostEl, 'transform', translate3d);\r\n\r\n                }\r\n\r\n                //evt.cancelable && evt.preventDefault();\r\n                evt.preventDefault()\r\n            }\r\n        },\r\n\r\n\t\t_nulling: function() {\r\n\r\n\t\t\tdnd.rootEl =\r\n\t\t\tdnd.dragEl =\r\n\t\t\tdnd.parentEl =\r\n\t\t\t//ghoster.ghostEl =\r\n\t\t\tdnd.nextEl =\r\n\t\t\tdnd.cloneEl =\r\n\t\t\t///lastDownEl =\r\n\r\n\t\t\tautoscroll.scrollEl =\r\n\t\t\tautoscroll.scrollParentEl =\r\n\t\t\tautoscroll.autoScrolls.length =\r\n\r\n\r\n\t\t\tdnd.tapEvt =\r\n\t\t\tdnd.touchEvt =\r\n\r\n\t\t\tdnd.oldIndex =\r\n\r\n\t\t\tdnd.putSortable =\r\n\t\t\tdnd.activeGroup =\r\n\t\t\tdnd.active = null;\r\n\r\n\t\t},\r\n\r\n\r\n\t};\r\n\r\n\r\n\treturn dnd;\r\n\t\r\n});"]}