{"version":3,"sources":["droppable.js"],"names":["define","langx","finder","styler","eventer","noder","geom","touch","dnd","moved","pastFirstInvertThresh","isCircumstantialInvert","_silent","_isScrolledPast","el","side","parent","scrollableParent","elSide","boundingRect","parentSide","scrollingElement","_unsilent","_index","selector","index","nodeName","toUpperCase","cloneEl","matches","[object Object]","sortable","options","this","_elm","elm","nativeDraggable","on","fromEl","toEl","dragEl","dragRect","targetEl","targetRect","originalEvt","willInsertAfter","evt","retVal","expando","onMoveFn","onMove","create","to","from","dragged","draggedRect","related","relatedRect","originalEvent","dispatchEvent","call","revert","lastMode","lastTarget","lastDirection","targetMoveDistance","target","group","activeSortable","active","isOwner","activeGroup","canSort","sort","rootEl","putSortable","nextEl","oldIndex","oldDraggableIndex","preventDefault","cancelable","closest","draggable","contains","animated","completed","disabled","lastPutMode","checkPull","checkPut","axis","_getDirection","_hideClone","parentEl","insertBefore","appendChild","elLastChild","lastChild","ignoreHidden","excluding","_lastChild","elRect","mouseOnAxis","clientY","clientX","mouseOnOppAxis","targetS2","bottom","right","targetS1Opp","left","top","targetS2Opp","_ghostIsLast","_showClone","_onMove","changed","parentNode","targetBeforeFirstSwap","direction","aligned","sortableMouseAligned","differentLevel","side1","scrolledPastTop","scrollBefore","scrollTop","el1","el2","el1Rect","el2Rect","el1S1Opp","el1S2Opp","el1OppLength","width","height","el2S1Opp","el2S2Opp","el2OppLength","_isElInRowColumn","invertSwap","swapThreshold","invertedSwapThreshold","isLastTarget","targetLength","targetS1","invert","_getInsertDirection","_getSwapDirection","nextSibling","nextElementSibling","after","moveVector","setTimeout","scrollBy","undefined","Math","abs","insertion","toggleClass","ghostClass","_animate","dragoverBubble","document","over","nearestEmptyInsertDetectEvent","stopPropagation","_dispatchEvent","newIndex","newDraggableIndex","off","_offUpEvents","dropBubble","remove","_disableDraggable","style","chosenClass","save","_nulling","ownerDocument","_onDrop","type","_onDragOver","dataTransfer","dropEffect","_globalDragOver"],"mappings":"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","file":"../droppable.js","sourcesContent":["define([\r\n\t\"skylark-langx\",\r\n\t\"skylark-domx-finder\",\r\n\t\"skylark-domx-styler\",\r\n\t\"skylark-domx-eventer\",\r\n\t\"skylark-domx-noder\",\r\n\t\"skylark-domx-geom\",\r\n\t\"skylark-devices-points/touch\",\r\n\t\"./dnd\"\r\n],function(langx,finder,styler,eventer,noder,geom,touch,dnd){\r\n\r\n\tvar\tmoved,\r\n\t    pastFirstInvertThresh,\r\n\t    isCircumstantialInvert,\r\n   \t\t_silent = false;\r\n\r\n\r\n\t/**\r\n\t * Checks if a side of an element is scrolled past a side of it's parents\r\n\t * @param  {HTMLElement}  el       The element who's side being scrolled out of view is in question\r\n\t * @param  {String}       side     Side of the element in question ('top', 'left', 'right', 'bottom')\r\n\t * @return {HTMLElement}           The parent scroll element that the el's side is scrolled past, or null if there is no such element\r\n\t */\r\n\tfunction _isScrolledPast(el, side) {\r\n\t\tvar parent = finder.scrollableParent(el, true),\r\n\t\t\telSide = geom.boundingRect(el)[side];\r\n\r\n\t\t/* jshint boss:true */\r\n\t\twhile (parent) {\r\n\t\t\tvar parentSide = geom.boundingRect(parent)[side],\r\n\t\t\t\tvisible;\r\n\r\n\t\t\tif (side === 'top' || side === 'left') {\r\n\t\t\t\tvisible = elSide >= parentSide;\r\n\t\t\t} else {\r\n\t\t\t\tvisible = elSide <= parentSide;\r\n\t\t\t}\r\n\r\n\t\t\tif (!visible) return parent;\r\n\r\n\t\t\tif (parent === noder.scrollingElement()) break;\r\n\r\n\t\t\tparent = finder.scrollableParent(parent, false);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\tfunction _unsilent() {\r\n\t\t_silent = false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\r\n\t * @param  {HTMLElement} el       Parent element\r\n\t * @return {HTMLElement}          The last child, ignoring ghostEl\r\n\t */\r\n\t function _lastChild(el) {\r\n\t\treturn finder.lastChild(el,{\r\n\t\t\tignoreHidden : true,\r\n\t\t\texcluding : []\r\n\t\t})\r\n\t}\r\n\r\n\t function _ghostIsLast(evt, axis, el) {\r\n\t\tvar elRect = geom.boundingRect(finder.lastChild(el,{ignoreHidden : true,excluding : []})),\r\n\t\t\tmouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,\r\n\t\t\tmouseOnOppAxis = axis === 'vertical' ? evt.clientX : evt.clientY,\r\n\t\t\ttargetS2 = axis === 'vertical' ? elRect.bottom : elRect.right,\r\n\t\t\ttargetS1Opp = axis === 'vertical' ? elRect.left : elRect.top,\r\n\t\t\ttargetS2Opp = axis === 'vertical' ? elRect.right : elRect.bottom,\r\n\t\t\tspacer = 10;\r\n\r\n\t\treturn (\r\n\t\t\taxis === 'vertical' ?\r\n\t\t\t\t(mouseOnOppAxis > targetS2Opp + spacer || mouseOnOppAxis <= targetS2Opp && mouseOnAxis > targetS2 && mouseOnOppAxis >= targetS1Opp) :\r\n\t\t\t\t(mouseOnAxis > targetS2 && mouseOnOppAxis > targetS1Opp || mouseOnAxis <= targetS2 && mouseOnOppAxis > targetS2Opp + spacer)\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tfunction _isClientInRowColumn(x, y, el, axis, options) {\r\n\t\tvar targetRect = geom.boundingRect(el),\r\n\t\t\ttargetS1Opp = axis === 'vertical' ? targetRect.left : targetRect.top,\r\n\t\t\ttargetS2Opp = axis === 'vertical' ? targetRect.right : targetRect.bottom,\r\n\t\t\tmouseOnOppAxis = axis === 'vertical' ? x : y;\r\n\r\n\t\treturn targetS1Opp < mouseOnOppAxis && mouseOnOppAxis < targetS2Opp;\r\n\t}\r\n\r\n\tfunction _isElInRowColumn(el1, el2, axis) {\r\n\t\t//var dragEl = dnd.active.dragEl;\r\n\r\n\t\tvar el1Rect = geom.boundingRect(el1),//el1 === dragEl && realDragElRect || geom.boundingRect(el1),\r\n\t\t\tel2Rect = geom.boundingRect(el2),//el2 === dragEl && realDragElRect || geom.boundingRect(el2),\r\n\t\t\tel1S1Opp = axis === 'vertical' ? el1Rect.left : el1Rect.top,\r\n\t\t\tel1S2Opp = axis === 'vertical' ? el1Rect.right : el1Rect.bottom,\r\n\t\t\tel1OppLength = axis === 'vertical' ? el1Rect.width : el1Rect.height,\r\n\t\t\tel2S1Opp = axis === 'vertical' ? el2Rect.left : el2Rect.top,\r\n\t\t\tel2S2Opp = axis === 'vertical' ? el2Rect.right : el2Rect.bottom,\r\n\t\t\tel2OppLength = axis === 'vertical' ? el2Rect.width : el2Rect.height;\r\n\r\n\t\treturn (\r\n\t\t\tel1S1Opp === el2S1Opp ||\r\n\t\t\tel1S2Opp === el2S2Opp ||\r\n\t\t\t(el1S1Opp + el1OppLength / 2) === (el2S1Opp + el2OppLength / 2)\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the index of an element within its parent for a selected set of\r\n\t * elements\r\n\t * @param  {HTMLElement} el\r\n\t * @param  {selector} selector\r\n\t * @return {number}\r\n\t */\r\n\tfunction _index(el, selector) {\r\n\t\treturn finder.index(el,function(el){\r\n\t\t\tif ((el.nodeName.toUpperCase() !== 'TEMPLATE') && el !== dnd.cloneEl && (!selector || finder.matches(el, selector))) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\t\t\t\r\n\t\t})\r\n\t}\t\r\n\r\n    function _globalDragOver(/**Event*/evt) {\r\n\t\tif (evt.dataTransfer) {\r\n\t\t\tevt.dataTransfer.dropEffect = 'move';\r\n\t\t}\r\n\t\tevt.cancelable && evt.preventDefault();\r\n\t}\r\n\r\n\tclass Droppable {\r\n\t\tconstructor(sortable,options) {\r\n\t\t\tthis.sortable = sortable;\r\n\t\t\tvar el = this.el= this._elm = sortable.elm();\r\n\t\t\tthis.options = options;\r\n\r\n\t\t\tif (sortable.nativeDraggable) {\r\n\t\t\t\teventer.on(el, 'dragover', this);\r\n\t\t\t\teventer.on(el, 'dragenter', this);\r\n\t\t        eventer.on(el, 'drop', this);\r\n\t\t\t}\r\n\t        eventer.on(el, 'selectstart', this);\r\n\t\t}\r\n\r\n\r\n\t\t_onMove (fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {\r\n\t\t\tvar evt,\r\n\t\t\t\tsortable = fromEl[dnd.expando],\r\n\t\t\t\tonMoveFn = sortable.options.onMove,\r\n\t\t\t\tretVal;\r\n\r\n\t\t\tevt = eventer.create(\"move\",{\r\n\t\t\t\tto : toEl,\r\n\t\t\t\tfrom : fromEl,\r\n\t\t\t\tdragged : dragEl,\r\n\t\t\t\tdraggedRect: dragRect,\r\n\t\t\t\trelated : targetEl || toEl,\r\n\t\t\t\trelatedRect : targetRect || geom.boundingRect(toEl),\r\n\t\t\t\twillInsertAfter : willInsertAfter,\r\n\t\t\t\toriginalEvent : originalEvt\r\n\t\t\t});\r\n\r\n\t\t\tfromEl.dispatchEvent(evt);\r\n\r\n\t\t\tif (onMoveFn) {\r\n\t\t\t\tretVal = onMoveFn.call(sortable, evt, originalEvt);\r\n\t\t\t}\r\n\r\n\t\t\treturn retVal;\r\n\t\t}\r\n\r\n\r\n\t\t// Returns true - if no further action is needed (either inserted or another condition)\r\n\t\t_onDragOver(/**Event*/evt) {\r\n\t\t\tvar el = this._elm,\r\n\t\t\t\ttarget = evt.target,\r\n\t\t\t\tdragRect,\r\n\t\t\t\ttargetRect,\r\n\t\t\t\trevert,\r\n\t\t\t\toptions = this.options,\r\n\t\t\t\tgroup = options.group,\r\n\t\t\t\tactiveSortable = dnd.active,\r\n\t\t\t\tisOwner = (dnd.activeGroup === group),\r\n\t\t\t\tcanSort = options.sort,\r\n\t\t\t\tsortable = this.sortable,\r\n\t\t\t\tdragEl = dnd.dragEl,\r\n\t\t\t\trootEl = dnd.active.elm(),\r\n\t\t\t\tputSortable = dnd.putSortable,\r\n\t\t\t\tnextEl = dnd.nextEl,\r\n\t\t\t\toldIndex = dnd.oldIndex,\r\n\t\t\t\toldDraggableIndex = dnd.oldDraggableIndex,\r\n\r\n\t\t\t\tlastMode, // 'swap' or 'insert'\r\n\t\t\t\tlastTarget,\r\n\t\t\t\tlastDirection,\r\n\t\t\t\ttargetMoveDistance;\r\n            //dnd.log(\"_onDragOver\",\"start\");\r\n\r\n\t\t\tif (_silent) return;\r\n\r\n\t\t\t// Return invocation when dragEl is inserted (or completed)\r\n\t\t\tfunction completed(insertion) {\r\n\t\t\t\tif (insertion) {\r\n\t\t\t\t\tif (isOwner) {\r\n\t\t\t\t\t\tactiveSortable._hideClone();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tactiveSortable._showClone(sortable);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (activeSortable) {\r\n\t\t\t\t\t\t// Set ghost class to new sortable's ghost class\r\n\t\t\t\t\t\tstyler.toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\r\n\t\t\t\t\t\tstyler.toggleClass(dragEl, options.ghostClass, true);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (putSortable !== sortable && sortable !== dnd.active) {\r\n\t\t\t\t\t\tputSortable = dnd.putSortable = sortable;\r\n\t\t\t\t\t} else if (sortable === dnd.active) {\r\n\t\t\t\t\t\tputSortable = dnd.putSortable =  null;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Animation\r\n\t\t\t\t\tdragRect && sortable._animate(dragRect, dragEl);\r\n\t\t\t\t\ttarget && targetRect && sortable._animate(targetRect, target);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\t// Null lastTarget if it is not inside a previously swapped element\r\n\t\t\t\tif ((target === dragEl && !dragEl.animated) || (target === el && !target.animated)) {\r\n\t\t\t\t\tlastTarget = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// no bubbling and not fallback\r\n\t\t\t\tif (!options.dragoverBubble && !evt.rootEl && target !== document) {\r\n\t\t\t\t\t//sortable._handleAutoScroll(evt);\r\n\t\t\t\t\tdnd.over(evt);\r\n\r\n\t\t\t\t\t// Do not detect for empty insert if already inserted\r\n\t\t\t\t\t!insertion && dnd.nearestEmptyInsertDetectEvent(evt);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t!options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Call when dragEl has been inserted\r\n\t\t\tfunction changed() {\r\n\t\t\t\tsortable._dispatchEvent(sortable, rootEl, 'change', target, el, rootEl, oldIndex, _index(dragEl), oldDraggableIndex, _index(dragEl, options.draggable), evt);\r\n\t\t\t}\r\n\r\n\r\n\t\t\t/**\r\n\t\t\t * Gets the direction dragEl must be swapped relative to target in order to make it\r\n\t\t\t * seem that dragEl has been \"inserted\" into that element's position\r\n\t\t\t * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\r\n\t\t\t * @return {Number}                   Direction dragEl must be swapped\r\n\t\t\t */\r\n\t\t\tfunction _getInsertDirection(target) {\r\n\t\t\t\tvar dragElIndex = _index(dragEl),\r\n\t\t\t\t\ttargetIndex = _index(target);\r\n\r\n\t\t\t\tif (dragElIndex < targetIndex) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfunction _getSwapDirection(evt, target, axis, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\r\n\t\t\t\tvar targetRect = geom.boundingRect(target),\r\n\t\t\t\t\tmouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,\r\n\t\t\t\t\ttargetLength = axis === 'vertical' ? targetRect.height : targetRect.width,\r\n\t\t\t\t\ttargetS1 = axis === 'vertical' ? targetRect.top : targetRect.left,\r\n\t\t\t\t\ttargetS2 = axis === 'vertical' ? targetRect.bottom : targetRect.right,\r\n\t\t\t\t\tdragRect = geom.boundingRect(dragEl),\r\n\t\t\t\t\tinvert = false;\r\n\r\n\r\n\t\t\t\tif (!invertSwap) {\r\n\t\t\t\t\t// Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\r\n\t\t\t\t\tif (isLastTarget && targetMoveDistance < targetLength * swapThreshold) { // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\r\n\t\t\t\t\t\t// check if past first invert threshold on side opposite of lastDirection\r\n\t\t\t\t\t\tif (!pastFirstInvertThresh &&\r\n\t\t\t\t\t\t\t(lastDirection === 1 ?\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2\r\n\t\t\t\t\t\t\t\t) :\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// past first invert threshold, do not restrict inverted threshold to dragEl shadow\r\n\t\t\t\t\t\t\tpastFirstInvertThresh = true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!pastFirstInvertThresh) {\r\n\t\t\t\t\t\t\tvar dragS1 = axis === 'vertical' ? dragRect.top : dragRect.left,\r\n\t\t\t\t\t\t\t\tdragS2 = axis === 'vertical' ? dragRect.bottom : dragRect.right;\r\n\t\t\t\t\t\t\t// dragEl shadow (target move distance shadow)\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tlastDirection === 1 ?\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\r\n\t\t\t\t\t\t\t\t) :\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis > targetS2 - targetMoveDistance\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\treturn lastDirection * -1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tinvert = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Regular\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tmouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold) / 2) &&\r\n\t\t\t\t\t\t\tmouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold) / 2)\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\treturn _getInsertDirection(target);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinvert = invert || invertSwap;\r\n\r\n\t\t\t\tif (invert) {\r\n\t\t\t\t\t// Invert of regular\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tmouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold / 2) ||\r\n\t\t\t\t\t\tmouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold / 2)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn ((mouseOnAxis > targetS1 + targetLength / 2) ? 1 : -1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (evt.preventDefault !== void 0) {\r\n\t\t\t\tevt.cancelable && evt.preventDefault();\r\n\t\t\t}\r\n\r\n\r\n\t\t\tmoved = true;\r\n\r\n\t\t\ttarget = finder.closest(target, options.draggable, el, true);\r\n\r\n\t\t\t// target is dragEl or target is animated\r\n\t\t\tif (dragEl.contains(evt.target) || target.animated) {\r\n\t\t\t\treturn completed(false);\r\n\t\t\t}\r\n\r\n\t\t\tif (activeSortable && !options.disabled &&\r\n\t\t\t\t(isOwner\r\n\t\t\t\t\t? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\r\n\t\t\t\t\t: (\r\n\t\t\t\t\t\tputSortable === this ||\r\n\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t(this.lastPutMode = dnd.activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&\r\n\t\t\t\t\t\t\tgroup.checkPut(this, activeSortable, dragEl, evt)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t) {\r\n\t\t\t\tvar axis = sortable._getDirection(evt, target);\r\n\r\n\t\t\t\tdragRect = geom.boundingRect(dragEl);\r\n\r\n\t\t\t\tif (revert) {\r\n\t\t\t\t\tthis._hideClone();\r\n\t\t\t\t\tdnd.parentEl = rootEl; // actualization\r\n\r\n\t\t\t\t\tif (nextEl) {\r\n\t\t\t\t\t\trootEl.insertBefore(dragEl, nextEl);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\trootEl.appendChild(dragEl);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn completed(true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar elLastChild = _lastChild(el);\r\n\r\n\t\t\t\tif (!elLastChild || _ghostIsLast(evt, axis, el) && !elLastChild.animated) {\r\n\t\t\t\t\t// assign target only if condition is true\r\n\t\t\t\t\tif (elLastChild && el === evt.target) {\r\n\t\t\t\t\t\ttarget = elLastChild;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (target) {\r\n\t\t\t\t\t\ttargetRect = geom.boundingRect(target);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (isOwner) {\r\n\t\t\t\t\t\tactiveSortable._hideClone();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tactiveSortable._showClone(this);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (this._onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\r\n\t\t\t\t\t\tel.appendChild(dragEl);\r\n\t\t\t\t\t\tdnd.parentEl = el; // actualization\r\n\t\t\t\t\t\t///realDragElRect = null;\r\n\r\n\t\t\t\t\t\tchanged();\r\n\t\t\t\t\t\treturn completed(true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (target && target !== dragEl && target.parentNode === el) {\r\n\t\t\t\t\tvar direction = 0,\r\n\t\t\t\t\t\ttargetBeforeFirstSwap,\r\n\t\t\t\t\t\taligned = target.sortableMouseAligned,\r\n\t\t\t\t\t\tdifferentLevel = dragEl.parentNode !== el,\r\n\t\t\t\t\t\tside1 = axis === 'vertical' ? 'top' : 'left',\r\n\t\t\t\t\t\tscrolledPastTop = _isScrolledPast(target, 'top') || _isScrolledPast(dragEl, 'top'),\r\n\t\t\t\t\t\tscrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\r\n\r\n\r\n\t\t\t\t\tif (lastTarget !== target) {\r\n\t\t\t\t\t\tlastMode = null;\r\n\t\t\t\t\t\ttargetBeforeFirstSwap = geom.boundingRect(target)[side1];\r\n\t\t\t\t\t\tpastFirstInvertThresh = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Reference: https://www.lucidchart.com/documents/view/10fa0e93-e362-4126-aca2-b709ee56bd8b/0\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\t_isElInRowColumn(dragEl, target, axis) && aligned ||\r\n\t\t\t\t\t\tdifferentLevel ||\r\n\t\t\t\t\t\tscrolledPastTop ||\r\n\t\t\t\t\t\toptions.invertSwap ||\r\n\t\t\t\t\t\tlastMode === 'insert' ||\r\n\t\t\t\t\t\t// Needed, in the case that we are inside target and inserted because not aligned... aligned will stay false while inside\r\n\t\t\t\t\t\t// and lastMode will change to 'insert', but we must swap\r\n\t\t\t\t\t\tlastMode === 'swap'\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\t// New target that we will be inside\r\n\t\t\t\t\t\tif (lastMode !== 'swap') {\r\n\t\t\t\t\t\t\tisCircumstantialInvert = options.invertSwap || differentLevel;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdirection = _getSwapDirection(evt, target, axis,\r\n\t\t\t\t\t\t\toptions.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold,\r\n\t\t\t\t\t\t\tisCircumstantialInvert,\r\n\t\t\t\t\t\t\tlastTarget === target);\r\n\t\t\t\t\t\tlastMode = 'swap';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Insert at position\r\n\t\t\t\t\t\tdirection = _getInsertDirection(target);\r\n\t\t\t\t\t\tlastMode = 'insert';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (direction === 0) return completed(false);\r\n\r\n\t\t\t\t\t///realDragElRect = null;\r\n\t\t\t\t\tlastTarget = target;\r\n\r\n\t\t\t\t\tlastDirection = direction;\r\n\r\n\t\t\t\t\ttargetRect = geom.boundingRect(target);\r\n\r\n\t\t\t\t\tvar nextSibling = target.nextElementSibling,\r\n\t\t\t\t\t\tafter = false;\r\n\r\n\t\t\t\t\tafter = direction === 1;\r\n\r\n\t\t\t\t\tvar moveVector = this._onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\r\n\r\n\t\t\t\t\tif (moveVector !== false) {\r\n\t\t\t\t\t\tif (moveVector === 1 || moveVector === -1) {\r\n\t\t\t\t\t\t\tafter = (moveVector === 1);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_silent = true;\r\n\t\t\t\t\t\tsetTimeout(_unsilent, 30);\r\n\r\n\t\t\t\t\t\tif (isOwner) {\r\n\t\t\t\t\t\t\tactiveSortable._hideClone();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tactiveSortable._showClone(this);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (after && !nextSibling) {\r\n\t\t\t\t\t\t\tel.appendChild(dragEl);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttarget.parentNode.insertBefore(dragEl, after ? nextSibling : target);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Undo chrome's scroll adjustment\r\n\t\t\t\t\t\tif (scrolledPastTop) {\r\n\t\t\t\t\t\t\tgeom.scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdnd.parentEl = dragEl.parentNode; // actualization\r\n\r\n\t\t\t\t\t\t// must be done before animation\r\n\t\t\t\t\t\tif (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\r\n\t\t\t\t\t\t\ttargetMoveDistance =  Math.abs(targetBeforeFirstSwap - geom.boundingRect(target)[side1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tchanged();\r\n\r\n\t\t\t\t\t\treturn completed(true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (el.contains(dragEl)) {\r\n\t\t\t\t\treturn completed(false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t_onDrop(/**Event*/evt) {\r\n\t\t\tvar el = this.el,\r\n\t\t\t\toptions = this.options,\r\n\t\t\t\tsortable = this.sortable,\r\n\t\t\t\trootEl = dnd.active.elm(),\r\n\t\t\t\tdragEl = dnd.dragEl,\r\n\t\t\t\tputSortable = dnd.putSortable,\r\n\t\t\t\tparentEl = dnd.parentEl,\r\n\t\t\t\toldIndex = dnd.oldIndex,\r\n\t\t\t\toldDraggableIndex = dnd.oldDraggableIndex,\r\n\t\t\t\tnextEl = dnd.nextEl,\r\n\t\t\t\tnewIndex,\r\n\t\t\t\tnewDraggableIndex;\r\n\r\n\r\n\t\t\tisCircumstantialInvert = false;\r\n\t\t\tpastFirstInvertThresh = false;\r\n\r\n\r\n\t\t\tif (sortable.nativeDraggable) {\r\n\t\t\t\teventer.off(document, 'drop', this);\r\n\t\t\t}\r\n\r\n\t\t\tthis._offUpEvents();\r\n\r\n\t\t\tif (evt) {\r\n\t\t\t\tif (moved) {\r\n\t\t\t\t\tevt.cancelable && evt.preventDefault();\r\n\t\t\t\t\t!options.dropBubble && evt.stopPropagation();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//ghoster.remove();\r\n\r\n\t\t\t\tif (rootEl === parentEl || (putSortable && putSortable.lastPutMode !== 'clone')) {\r\n\t\t\t\t\t// Remove clone\r\n\t\t\t\t\tnoder.remove(dnd.cloneEl);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (dragEl) {\r\n\r\n\t\t\t\t\tdnd._disableDraggable(dragEl);\r\n\t\t\t\t\tdragEl.style['will-change'] = '';\r\n\r\n\t\t\t\t\t// Remove class'sd\r\n\t\t\t\t\tstyler.toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\r\n\t\t\t\t\tstyler.toggleClass(dragEl, this.options.chosenClass, false);\r\n\r\n\t\t\t\t\t// Drag stop event\r\n\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'unchoose', dragEl, parentEl, rootEl, oldIndex, null, oldDraggableIndex, null, evt);\r\n\r\n\t\t\t\t\tif (rootEl !== parentEl) {\r\n\t\t\t\t\t\tnewIndex = _index(dragEl);\r\n\t\t\t\t\t\tnewDraggableIndex = _index(dragEl, options.draggable);\r\n\r\n\t\t\t\t\t\tif (newIndex >= 0) {\r\n\t\t\t\t\t\t\t// Add event\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(null, parentEl, 'add', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\r\n\t\t\t\t\t\t\t// Remove event\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'remove', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\r\n\t\t\t\t\t\t\t// drag from one list and drop into another\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(null, parentEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tputSortable && putSortable.save();\r\n\t\t\t\t\t}else {\r\n\t\t\t\t\t\tif (dragEl.nextSibling !== nextEl) {\r\n\t\t\t\t\t\t\t// Get the index of the dragged element within its parent\r\n\t\t\t\t\t\t\tnewIndex = _index(dragEl);\r\n\t\t\t\t\t\t\tnewDraggableIndex = _index(dragEl, options.draggable);\r\n\r\n\t\t\t\t\t\t\tif (newIndex >= 0) {\r\n\t\t\t\t\t\t\t\t// drag & drop within the same list\r\n\t\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'update', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (dnd.active) {\r\n\t\t\t\t\t\t/* jshint eqnull:true */\r\n\t\t\t\t\t\tif (newIndex == null || newIndex === -1) {\r\n\t\t\t\t\t\t\tnewIndex = oldIndex;\r\n\t\t\t\t\t\t\tnewDraggableIndex = oldDraggableIndex;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'end', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\r\n\t\t\t\t\t\t// Save sorting\r\n\t\t\t\t\t\tsortable.save();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tthis._nulling();\r\n\t\t}\r\n\r\n\t\t_offUpEvents () {\r\n\t\t\tvar ownerDocument = this.el.ownerDocument;\r\n\r\n\t\t\teventer.off(ownerDocument, 'mouseup', this._onDrop);\r\n\t\t\teventer.off(document, 'selectstart', this);\r\n\t\t}\r\n\r\n\t\t_nulling() {\r\n\r\n\t\t\tmoved =\tnull;\r\n\r\n\t\t}\r\n\r\n\t\thandleEvent (/**Event*/evt) {\r\n\t\t\tswitch (evt.type) {\r\n\t\t\t\tcase 'drop':\r\n\t\t\t\t\tthis._onDrop(evt);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'dragenter':\r\n\t\t\t\tcase 'dragover':\r\n\t\t\t\t\tif (dnd.dragEl) {\r\n\t\t\t\t\t\tthis._onDragOver(evt);\r\n\t\t\t\t\t\t_globalDragOver(evt);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'selectstart':\r\n\t\t\t\t\tevt.preventDefault();\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\treturn Droppable;\r\n});"]}