{"version":3,"sources":["droppable.js"],"names":["define","langx","finder","styler","eventer","noder","geom","DndDroppable","dnd","moved","pastFirstInvertThresh","isCircumstantialInvert","_silent","_isScrolledPast","el","side","parent","scrollableParent","elSide","boundingRect","parentSide","visible","scrollingElement","_unsilent","_lastChild","lastChild","ignoreHidden","excluding","_ghostIsLast","evt","axis","elRect","mouseOnAxis","clientY","clientX","mouseOnOppAxis","targetS2","bottom","right","targetS1Opp","left","top","targetS2Opp","_isElInRowColumn","el1","el2","el1Rect","el2Rect","el1S1Opp","el1S2Opp","el1OppLength","width","height","el2S1Opp","el2S2Opp","el2OppLength","_index","selector","index","nodeName","toUpperCase","cloneEl","matches","_globalDragOver","dataTransfer","dropEffect","cancelable","preventDefault","constructor","sortable","options","this","_elm","elm","self","_dndDroppable","started","e","acceptable","activeClass","hoverClass","overing","dragEl","_onDragOver","originalEvent","dropped","_onDrop","on","_onMove","fromEl","toEl","dragRect","targetEl","targetRect","originalEvt","willInsertAfter","retVal","expando","onMoveFn","onMove","create","to","from","dragged","draggedRect","related","relatedRect","dispatchEvent","call","lastMode","targetMoveDistance","target","group","activeSortable","active","isOwner","activeGroup","canSort","sort","rootEl","putSortable","nextEl","oldIndex","oldDraggableIndex","closest","draggable","contains","animated","completed","disabled","revert","lastPutMode","checkPull","checkPut","_getDirection","_hideClone","parentEl","insertBefore","appendChild","elLastChild","_showClone","changed","parentNode","targetBeforeFirstSwap","direction","aligned","sortableMouseAligned","differentLevel","side1","scrolledPastTop","scrollBefore","scrollTop","lastTarget","invertSwap","swapThreshold","invertedSwapThreshold","isLastTarget","targetLength","targetS1","invert","lastDirection","_getInsertDirection","nextSibling","nextElementSibling","after","moveVector","setTimeout","scrollBy","undefined","Math","abs","insertion","toggleClass","ghostClass","_animate","dragoverBubble","document","over","nearestEmptyInsertDetectEvent","stopPropagation","_dispatchEvent","newIndex","newDraggableIndex","nativeDraggable","off","_offUpEvents","dropBubble","remove","_disableDraggable","style","chosenClass","save","_nulling","ownerDocument","handleEvent","type","destroy","his"],"mappings":"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","file":"../droppable.js","sourcesContent":["define([\r\n\t\"skylark-langx\",\r\n\t\"skylark-domx-finder\",\r\n\t\"skylark-domx-styler\",\r\n\t\"skylark-domx-eventer\",\r\n\t\"skylark-domx-noder\",\r\n\t\"skylark-domx-geom\",\r\n    \"skylark-domx-plugins-dnd/droppable\",\r\n\t\"./dnd\"\r\n],function(langx,finder,styler,eventer,noder,geom,DndDroppable,dnd){\r\n\r\n\tvar\tmoved,\r\n\t    pastFirstInvertThresh,\r\n\t    isCircumstantialInvert,\r\n   \t\t_silent = false;\r\n\r\n\r\n\t/**\r\n\t * Checks if a side of an element is scrolled past a side of it's parents\r\n\t * @param  {HTMLElement}  el       The element who's side being scrolled out of view is in question\r\n\t * @param  {String}       side     Side of the element in question ('top', 'left', 'right', 'bottom')\r\n\t * @return {HTMLElement}           The parent scroll element that the el's side is scrolled past, or null if there is no such element\r\n\t */\r\n\tfunction _isScrolledPast(el, side) {\r\n\t\tvar parent = finder.scrollableParent(el, true),\r\n\t\t\telSide = geom.boundingRect(el)[side];\r\n\r\n\t\t/* jshint boss:true */\r\n\t\twhile (parent) {\r\n\t\t\tvar parentSide = geom.boundingRect(parent)[side],\r\n\t\t\t\tvisible;\r\n\r\n\t\t\tif (side === 'top' || side === 'left') {\r\n\t\t\t\tvisible = elSide >= parentSide;\r\n\t\t\t} else {\r\n\t\t\t\tvisible = elSide <= parentSide;\r\n\t\t\t}\r\n\r\n\t\t\tif (!visible) return parent;\r\n\r\n\t\t\tif (parent === noder.scrollingElement()) break;\r\n\r\n\t\t\tparent = finder.scrollableParent(parent, false);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\tfunction _unsilent() {\r\n\t\t_silent = false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\r\n\t * @param  {HTMLElement} el       Parent element\r\n\t * @return {HTMLElement}          The last child, ignoring ghostEl\r\n\t */\r\n\t function _lastChild(el) {\r\n\t\treturn finder.lastChild(el,{\r\n\t\t\tignoreHidden : true,\r\n\t\t\texcluding : []\r\n\t\t})\r\n\t}\r\n\r\n\t function _ghostIsLast(evt, axis, el) {\r\n\t\tvar elRect = geom.boundingRect(finder.lastChild(el,{ignoreHidden : true,excluding : []})),\r\n\t\t\tmouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,\r\n\t\t\tmouseOnOppAxis = axis === 'vertical' ? evt.clientX : evt.clientY,\r\n\t\t\ttargetS2 = axis === 'vertical' ? elRect.bottom : elRect.right,\r\n\t\t\ttargetS1Opp = axis === 'vertical' ? elRect.left : elRect.top,\r\n\t\t\ttargetS2Opp = axis === 'vertical' ? elRect.right : elRect.bottom,\r\n\t\t\tspacer = 10;\r\n\r\n\t\treturn (\r\n\t\t\taxis === 'vertical' ?\r\n\t\t\t\t(mouseOnOppAxis > targetS2Opp + spacer || mouseOnOppAxis <= targetS2Opp && mouseOnAxis > targetS2 && mouseOnOppAxis >= targetS1Opp) :\r\n\t\t\t\t(mouseOnAxis > targetS2 && mouseOnOppAxis > targetS1Opp || mouseOnAxis <= targetS2 && mouseOnOppAxis > targetS2Opp + spacer)\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tfunction _isClientInRowColumn(x, y, el, axis, options) {\r\n\t\tvar targetRect = geom.boundingRect(el),\r\n\t\t\ttargetS1Opp = axis === 'vertical' ? targetRect.left : targetRect.top,\r\n\t\t\ttargetS2Opp = axis === 'vertical' ? targetRect.right : targetRect.bottom,\r\n\t\t\tmouseOnOppAxis = axis === 'vertical' ? x : y;\r\n\r\n\t\treturn targetS1Opp < mouseOnOppAxis && mouseOnOppAxis < targetS2Opp;\r\n\t}\r\n\r\n\tfunction _isElInRowColumn(el1, el2, axis) {\r\n\t\t//var dragEl = dnd.active.dragEl;\r\n\r\n\t\tvar el1Rect = geom.boundingRect(el1),//el1 === dragEl && realDragElRect || geom.boundingRect(el1),\r\n\t\t\tel2Rect = geom.boundingRect(el2),//el2 === dragEl && realDragElRect || geom.boundingRect(el2),\r\n\t\t\tel1S1Opp = axis === 'vertical' ? el1Rect.left : el1Rect.top,\r\n\t\t\tel1S2Opp = axis === 'vertical' ? el1Rect.right : el1Rect.bottom,\r\n\t\t\tel1OppLength = axis === 'vertical' ? el1Rect.width : el1Rect.height,\r\n\t\t\tel2S1Opp = axis === 'vertical' ? el2Rect.left : el2Rect.top,\r\n\t\t\tel2S2Opp = axis === 'vertical' ? el2Rect.right : el2Rect.bottom,\r\n\t\t\tel2OppLength = axis === 'vertical' ? el2Rect.width : el2Rect.height;\r\n\r\n\t\treturn (\r\n\t\t\tel1S1Opp === el2S1Opp ||\r\n\t\t\tel1S2Opp === el2S2Opp ||\r\n\t\t\t(el1S1Opp + el1OppLength / 2) === (el2S1Opp + el2OppLength / 2)\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the index of an element within its parent for a selected set of\r\n\t * elements\r\n\t * @param  {HTMLElement} el\r\n\t * @param  {selector} selector\r\n\t * @return {number}\r\n\t */\r\n\tfunction _index(el, selector) {\r\n\t\treturn finder.index(el,function(el){\r\n\t\t\tif ((el.nodeName.toUpperCase() !== 'TEMPLATE') && el !== dnd.cloneEl && (!selector || finder.matches(el, selector))) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\t\t\t\r\n\t\t})\r\n\t}\t\r\n\r\n    function _globalDragOver(/**Event*/evt) {\r\n\t\tif (evt.dataTransfer) {\r\n\t\t\tevt.dataTransfer.dropEffect = 'move';\r\n\t\t}\r\n\t\tevt.cancelable && evt.preventDefault();\r\n\t}\r\n\r\n\tclass Droppable {\r\n\t\tconstructor(sortable,options) {\r\n\t\t\tthis.sortable = sortable;\r\n\t\t\tvar el = this.el= this._elm = sortable.elm();\r\n\t\t\tthis.options = options;\r\n\r\n\r\n\t\t\tvar self = this;\r\n\r\n            this._dndDroppable = new DndDroppable(el,{\r\n\t            started: function(e) {\r\n\t                e.acceptable = true;\r\n\t                e.activeClass = \"active\";\r\n\t                e.hoverClass = \"over\";\r\n\t            },\r\n\r\n                overing : function(e) {\r\n\t\t\t\t\tif (dnd.dragEl) {\r\n\t\t\t\t\t\tself._onDragOver(e.originalEvent);\r\n\t\t\t\t\t\t_globalDragOver(e.originalEvent);\r\n\t\t\t\t\t}\r\n                },\r\n\r\n\r\n                dropped : function(e) {\r\n                    self._onDrop(e.originalEvent);\r\n                }\r\n            });\r\n\r\n\r\n\r\n\t\t\t///if (sortable.nativeDraggable) {\r\n\t\t\t///\teventer.on(el, 'dragover', this);\r\n\t\t\t///\teventer.on(el, 'dragenter', this);\r\n\t\t        eventer.on(el, 'drop', this);\r\n\t\t\t///}\r\n\t        eventer.on(el, 'selectstart', this);\r\n\t\t}\r\n\r\n\r\n\t\t_onMove (fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {\r\n\t\t\tvar evt,\r\n\t\t\t\tsortable = fromEl[dnd.expando],\r\n\t\t\t\tonMoveFn = sortable.options.onMove,\r\n\t\t\t\tretVal;\r\n\r\n\t\t\tevt = eventer.create(\"move\",{\r\n\t\t\t\tto : toEl,\r\n\t\t\t\tfrom : fromEl,\r\n\t\t\t\tdragged : dragEl,\r\n\t\t\t\tdraggedRect: dragRect,\r\n\t\t\t\trelated : targetEl || toEl,\r\n\t\t\t\trelatedRect : targetRect || geom.boundingRect(toEl),\r\n\t\t\t\twillInsertAfter : willInsertAfter,\r\n\t\t\t\toriginalEvent : originalEvt\r\n\t\t\t});\r\n\r\n\t\t\tfromEl.dispatchEvent(evt);\r\n\r\n\t\t\tif (onMoveFn) {\r\n\t\t\t\tretVal = onMoveFn.call(sortable, evt, originalEvt);\r\n\t\t\t}\r\n\r\n\t\t\treturn retVal;\r\n\t\t}\r\n\r\n\r\n\t\t// Returns true - if no further action is needed (either inserted or another condition)\r\n\t\t_onDragOver(/**Event*/evt) {\r\n\t\t\tvar el = this._elm,\r\n\t\t\t\ttarget = evt.target,\r\n\t\t\t\tdragRect,\r\n\t\t\t\ttargetRect,\r\n\t\t\t\trevert,\r\n\t\t\t\toptions = this.options,\r\n\t\t\t\tgroup = options.group,\r\n\t\t\t\tactiveSortable = dnd.active,\r\n\t\t\t\tisOwner = (dnd.activeGroup === group),\r\n\t\t\t\tcanSort = options.sort,\r\n\t\t\t\tsortable = this.sortable,\r\n\t\t\t\tdragEl = dnd.dragEl,\r\n\t\t\t\trootEl = dnd.active.elm(),\r\n\t\t\t\tputSortable = dnd.putSortable,\r\n\t\t\t\tnextEl = dnd.nextEl,\r\n\t\t\t\toldIndex = dnd.oldIndex,\r\n\t\t\t\toldDraggableIndex = dnd.oldDraggableIndex,\r\n\r\n\t\t\t\tlastMode, // 'swap' or 'insert'\r\n\t\t\t\tlastTarget,\r\n\t\t\t\tlastDirection,\r\n\t\t\t\ttargetMoveDistance;\r\n            //dnd.log(\"_onDragOver\",\"start\");\r\n\r\n\t\t\tif (_silent) return;\r\n\r\n\t\t\t// Return invocation when dragEl is inserted (or completed)\r\n\t\t\tfunction completed(insertion) {\r\n\t\t\t\tif (insertion) {\r\n\t\t\t\t\tif (isOwner) {\r\n\t\t\t\t\t\tactiveSortable._hideClone();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tactiveSortable._showClone(sortable);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (activeSortable) {\r\n\t\t\t\t\t\t// Set ghost class to new sortable's ghost class\r\n\t\t\t\t\t\tstyler.toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\r\n\t\t\t\t\t\tstyler.toggleClass(dragEl, options.ghostClass, true);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (putSortable !== sortable && sortable !== dnd.active) {\r\n\t\t\t\t\t\tputSortable = dnd.putSortable = sortable;\r\n\t\t\t\t\t} else if (sortable === dnd.active) {\r\n\t\t\t\t\t\tputSortable = dnd.putSortable =  null;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Animation\r\n\t\t\t\t\tdragRect && sortable._animate(dragRect, dragEl);\r\n\t\t\t\t\ttarget && targetRect && sortable._animate(targetRect, target);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\t// Null lastTarget if it is not inside a previously swapped element\r\n\t\t\t\tif ((target === dragEl && !dragEl.animated) || (target === el && !target.animated)) {\r\n\t\t\t\t\tlastTarget = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// no bubbling and not fallback\r\n\t\t\t\tif (!options.dragoverBubble && !evt.rootEl && target !== document) {\r\n\t\t\t\t\t//sortable._handleAutoScroll(evt);\r\n\t\t\t\t\tdnd.over(evt);\r\n\r\n\t\t\t\t\t// Do not detect for empty insert if already inserted\r\n\t\t\t\t\t!insertion && dnd.nearestEmptyInsertDetectEvent(evt);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t!options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Call when dragEl has been inserted\r\n\t\t\tfunction changed() {\r\n\t\t\t\tsortable._dispatchEvent(sortable, rootEl, 'change', target, el, rootEl, oldIndex, _index(dragEl), oldDraggableIndex, _index(dragEl, options.draggable), evt);\r\n\t\t\t}\r\n\r\n\r\n\t\t\t/**\r\n\t\t\t * Gets the direction dragEl must be swapped relative to target in order to make it\r\n\t\t\t * seem that dragEl has been \"inserted\" into that element's position\r\n\t\t\t * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\r\n\t\t\t * @return {Number}                   Direction dragEl must be swapped\r\n\t\t\t */\r\n\t\t\tfunction _getInsertDirection(target) {\r\n\t\t\t\tvar dragElIndex = _index(dragEl),\r\n\t\t\t\t\ttargetIndex = _index(target);\r\n\r\n\t\t\t\tif (dragElIndex < targetIndex) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfunction _getSwapDirection(evt, target, axis, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\r\n\t\t\t\tvar targetRect = geom.boundingRect(target),\r\n\t\t\t\t\tmouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,\r\n\t\t\t\t\ttargetLength = axis === 'vertical' ? targetRect.height : targetRect.width,\r\n\t\t\t\t\ttargetS1 = axis === 'vertical' ? targetRect.top : targetRect.left,\r\n\t\t\t\t\ttargetS2 = axis === 'vertical' ? targetRect.bottom : targetRect.right,\r\n\t\t\t\t\tdragRect = geom.boundingRect(dragEl),\r\n\t\t\t\t\tinvert = false;\r\n\r\n\r\n\t\t\t\tif (!invertSwap) {\r\n\t\t\t\t\t// Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\r\n\t\t\t\t\tif (isLastTarget && targetMoveDistance < targetLength * swapThreshold) { // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\r\n\t\t\t\t\t\t// check if past first invert threshold on side opposite of lastDirection\r\n\t\t\t\t\t\tif (!pastFirstInvertThresh &&\r\n\t\t\t\t\t\t\t(lastDirection === 1 ?\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2\r\n\t\t\t\t\t\t\t\t) :\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// past first invert threshold, do not restrict inverted threshold to dragEl shadow\r\n\t\t\t\t\t\t\tpastFirstInvertThresh = true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!pastFirstInvertThresh) {\r\n\t\t\t\t\t\t\tvar dragS1 = axis === 'vertical' ? dragRect.top : dragRect.left,\r\n\t\t\t\t\t\t\t\tdragS2 = axis === 'vertical' ? dragRect.bottom : dragRect.right;\r\n\t\t\t\t\t\t\t// dragEl shadow (target move distance shadow)\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tlastDirection === 1 ?\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\r\n\t\t\t\t\t\t\t\t) :\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis > targetS2 - targetMoveDistance\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\treturn lastDirection * -1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tinvert = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Regular\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tmouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold) / 2) &&\r\n\t\t\t\t\t\t\tmouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold) / 2)\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\treturn _getInsertDirection(target);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinvert = invert || invertSwap;\r\n\r\n\t\t\t\tif (invert) {\r\n\t\t\t\t\t// Invert of regular\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tmouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold / 2) ||\r\n\t\t\t\t\t\tmouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold / 2)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn ((mouseOnAxis > targetS1 + targetLength / 2) ? 1 : -1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (evt.preventDefault !== void 0) {\r\n\t\t\t\tevt.cancelable && evt.preventDefault();\r\n\t\t\t}\r\n\r\n\r\n\t\t\tmoved = true;\r\n\r\n\t\t\ttarget = finder.closest(target, options.draggable, el, true);\r\n\r\n\t\t\t// target is dragEl or target is animated\r\n\t\t\tif (dragEl.contains(evt.target) || target.animated) {\r\n\t\t\t\treturn completed(false);\r\n\t\t\t}\r\n\r\n\t\t\tif (activeSortable && !options.disabled &&\r\n\t\t\t\t(isOwner\r\n\t\t\t\t\t? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\r\n\t\t\t\t\t: (\r\n\t\t\t\t\t\tputSortable === this ||\r\n\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t(this.lastPutMode = dnd.activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&\r\n\t\t\t\t\t\t\tgroup.checkPut(this, activeSortable, dragEl, evt)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t) {\r\n\t\t\t\tvar axis = sortable._getDirection(evt, target);\r\n\r\n\t\t\t\tdragRect = geom.boundingRect(dragEl);\r\n\r\n\t\t\t\tif (revert) {\r\n\t\t\t\t\tthis._hideClone();\r\n\t\t\t\t\tdnd.parentEl = rootEl; // actualization\r\n\r\n\t\t\t\t\tif (nextEl) {\r\n\t\t\t\t\t\trootEl.insertBefore(dragEl, nextEl);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\trootEl.appendChild(dragEl);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn completed(true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar elLastChild = _lastChild(el);\r\n\r\n\t\t\t\tif (!elLastChild || _ghostIsLast(evt, axis, el) && !elLastChild.animated) {\r\n\t\t\t\t\t// assign target only if condition is true\r\n\t\t\t\t\tif (elLastChild && el === evt.target) {\r\n\t\t\t\t\t\ttarget = elLastChild;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (target) {\r\n\t\t\t\t\t\ttargetRect = geom.boundingRect(target);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (isOwner) {\r\n\t\t\t\t\t\tactiveSortable._hideClone();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tactiveSortable._showClone(this);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (this._onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\r\n\t\t\t\t\t\tel.appendChild(dragEl);\r\n\t\t\t\t\t\tdnd.parentEl = el; // actualization\r\n\t\t\t\t\t\t///realDragElRect = null;\r\n\r\n\t\t\t\t\t\tchanged();\r\n\t\t\t\t\t\treturn completed(true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (target && target !== dragEl && target.parentNode === el) {\r\n\t\t\t\t\tvar direction = 0,\r\n\t\t\t\t\t\ttargetBeforeFirstSwap,\r\n\t\t\t\t\t\taligned = target.sortableMouseAligned,\r\n\t\t\t\t\t\tdifferentLevel = dragEl.parentNode !== el,\r\n\t\t\t\t\t\tside1 = axis === 'vertical' ? 'top' : 'left',\r\n\t\t\t\t\t\tscrolledPastTop = _isScrolledPast(target, 'top') || _isScrolledPast(dragEl, 'top'),\r\n\t\t\t\t\t\tscrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\r\n\r\n\r\n\t\t\t\t\tif (lastTarget !== target) {\r\n\t\t\t\t\t\tlastMode = null;\r\n\t\t\t\t\t\ttargetBeforeFirstSwap = geom.boundingRect(target)[side1];\r\n\t\t\t\t\t\tpastFirstInvertThresh = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Reference: https://www.lucidchart.com/documents/view/10fa0e93-e362-4126-aca2-b709ee56bd8b/0\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\t_isElInRowColumn(dragEl, target, axis) && aligned ||\r\n\t\t\t\t\t\tdifferentLevel ||\r\n\t\t\t\t\t\tscrolledPastTop ||\r\n\t\t\t\t\t\toptions.invertSwap ||\r\n\t\t\t\t\t\tlastMode === 'insert' ||\r\n\t\t\t\t\t\t// Needed, in the case that we are inside target and inserted because not aligned... aligned will stay false while inside\r\n\t\t\t\t\t\t// and lastMode will change to 'insert', but we must swap\r\n\t\t\t\t\t\tlastMode === 'swap'\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\t// New target that we will be inside\r\n\t\t\t\t\t\tif (lastMode !== 'swap') {\r\n\t\t\t\t\t\t\tisCircumstantialInvert = options.invertSwap || differentLevel;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdirection = _getSwapDirection(evt, target, axis,\r\n\t\t\t\t\t\t\toptions.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold,\r\n\t\t\t\t\t\t\tisCircumstantialInvert,\r\n\t\t\t\t\t\t\tlastTarget === target);\r\n\t\t\t\t\t\tlastMode = 'swap';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Insert at position\r\n\t\t\t\t\t\tdirection = _getInsertDirection(target);\r\n\t\t\t\t\t\tlastMode = 'insert';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (direction === 0) return completed(false);\r\n\r\n\t\t\t\t\t///realDragElRect = null;\r\n\t\t\t\t\tlastTarget = target;\r\n\r\n\t\t\t\t\tlastDirection = direction;\r\n\r\n\t\t\t\t\ttargetRect = geom.boundingRect(target);\r\n\r\n\t\t\t\t\tvar nextSibling = target.nextElementSibling,\r\n\t\t\t\t\t\tafter = false;\r\n\r\n\t\t\t\t\tafter = direction === 1;\r\n\r\n\t\t\t\t\tvar moveVector = this._onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\r\n\r\n\t\t\t\t\tif (moveVector !== false) {\r\n\t\t\t\t\t\tif (moveVector === 1 || moveVector === -1) {\r\n\t\t\t\t\t\t\tafter = (moveVector === 1);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_silent = true;\r\n\t\t\t\t\t\tsetTimeout(_unsilent, 30);\r\n\r\n\t\t\t\t\t\tif (isOwner) {\r\n\t\t\t\t\t\t\tactiveSortable._hideClone();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tactiveSortable._showClone(this);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (after && !nextSibling) {\r\n\t\t\t\t\t\t\tel.appendChild(dragEl);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttarget.parentNode.insertBefore(dragEl, after ? nextSibling : target);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Undo chrome's scroll adjustment\r\n\t\t\t\t\t\tif (scrolledPastTop) {\r\n\t\t\t\t\t\t\tgeom.scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdnd.parentEl = dragEl.parentNode; // actualization\r\n\r\n\t\t\t\t\t\t// must be done before animation\r\n\t\t\t\t\t\tif (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\r\n\t\t\t\t\t\t\ttargetMoveDistance =  Math.abs(targetBeforeFirstSwap - geom.boundingRect(target)[side1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tchanged();\r\n\r\n\t\t\t\t\t\treturn completed(true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (el.contains(dragEl)) {\r\n\t\t\t\t\treturn completed(false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t_onDrop(/**Event*/evt) {\r\n\t\t\tvar el = this.el,\r\n\t\t\t\toptions = this.options,\r\n\t\t\t\tsortable = this.sortable,\r\n\t\t\t\trootEl = dnd.active.elm(),\r\n\t\t\t\tdragEl = dnd.dragEl,\r\n\t\t\t\tputSortable = dnd.putSortable,\r\n\t\t\t\tparentEl = dnd.parentEl,\r\n\t\t\t\toldIndex = dnd.oldIndex,\r\n\t\t\t\toldDraggableIndex = dnd.oldDraggableIndex,\r\n\t\t\t\tnextEl = dnd.nextEl,\r\n\t\t\t\tnewIndex,\r\n\t\t\t\tnewDraggableIndex;\r\n\r\n\r\n\t\t\tisCircumstantialInvert = false;\r\n\t\t\tpastFirstInvertThresh = false;\r\n\r\n\r\n\t\t\tif (sortable.nativeDraggable) {\r\n\t\t\t\teventer.off(document, 'drop', this);\r\n\t\t\t}\r\n\r\n\t\t\tthis._offUpEvents();\r\n\r\n\t\t\tif (evt) {\r\n\t\t\t\tif (moved) {\r\n\t\t\t\t\tevt.cancelable && evt.preventDefault();\r\n\t\t\t\t\t!options.dropBubble && evt.stopPropagation();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//ghoster.remove();\r\n\r\n\t\t\t\tif (rootEl === parentEl || (putSortable && putSortable.lastPutMode !== 'clone')) {\r\n\t\t\t\t\t// Remove clone\r\n\t\t\t\t\tnoder.remove(dnd.cloneEl);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (dragEl) {\r\n\r\n\t\t\t\t\tdnd._disableDraggable(dragEl);\r\n\t\t\t\t\tdragEl.style['will-change'] = '';\r\n\r\n\t\t\t\t\t// Remove class'sd\r\n\t\t\t\t\tstyler.toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\r\n\t\t\t\t\tstyler.toggleClass(dragEl, this.options.chosenClass, false);\r\n\r\n\t\t\t\t\t// Drag stop event\r\n\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'unchoose', dragEl, parentEl, rootEl, oldIndex, null, oldDraggableIndex, null, evt);\r\n\r\n\t\t\t\t\tif (rootEl !== parentEl) {\r\n\t\t\t\t\t\tnewIndex = _index(dragEl);\r\n\t\t\t\t\t\tnewDraggableIndex = _index(dragEl, options.draggable);\r\n\r\n\t\t\t\t\t\tif (newIndex >= 0) {\r\n\t\t\t\t\t\t\t// Add event\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(null, parentEl, 'add', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\r\n\t\t\t\t\t\t\t// Remove event\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'remove', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\r\n\t\t\t\t\t\t\t// drag from one list and drop into another\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(null, parentEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tputSortable && putSortable.save();\r\n\t\t\t\t\t}else {\r\n\t\t\t\t\t\tif (dragEl.nextSibling !== nextEl) {\r\n\t\t\t\t\t\t\t// Get the index of the dragged element within its parent\r\n\t\t\t\t\t\t\tnewIndex = _index(dragEl);\r\n\t\t\t\t\t\t\tnewDraggableIndex = _index(dragEl, options.draggable);\r\n\r\n\t\t\t\t\t\t\tif (newIndex >= 0) {\r\n\t\t\t\t\t\t\t\t// drag & drop within the same list\r\n\t\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'update', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (dnd.active) {\r\n\t\t\t\t\t\t/* jshint eqnull:true */\r\n\t\t\t\t\t\tif (newIndex == null || newIndex === -1) {\r\n\t\t\t\t\t\t\tnewIndex = oldIndex;\r\n\t\t\t\t\t\t\tnewDraggableIndex = oldDraggableIndex;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'end', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\r\n\t\t\t\t\t\t// Save sorting\r\n\t\t\t\t\t\tsortable.save();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tthis._nulling();\r\n\t\t}\r\n\r\n\t\t_offUpEvents () {\r\n\t\t\tvar ownerDocument = this.el.ownerDocument;\r\n\r\n\t\t\teventer.off(ownerDocument, 'mouseup', this._onDrop);\r\n\t\t\teventer.off(document, 'selectstart', this);\r\n\t\t}\r\n\r\n\t\t_nulling() {\r\n\r\n\t\t\tmoved =\tnull;\r\n\r\n\t\t}\r\n\r\n\t\thandleEvent (/**Event*/evt) {\r\n\t\t\tswitch (evt.type) {\r\n\t\t\t\tcase 'drop':\r\n\t\t\t\t\tthis._onDrop(evt);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'dragenter':\r\n\t\t\t\tcase 'dragover':\r\n\t\t\t\t\tif (dnd.dragEl) {\r\n\t\t\t\t\t\tthis._onDragOver(evt);\r\n\t\t\t\t\t\t_globalDragOver(evt);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'selectstart':\r\n\t\t\t\t\tevt.preventDefault();\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdestroy() {\r\n\t\t\tvar sortable = this.sortable;\r\n\r\n\t\t\t///if (sortable.nativeDraggable) {\r\n\t\t\t///\teventer.off(el, 'dragover', this);\r\n\t\t   ///\t\teventer.off(el, 'dragenter', this);\r\n\t\t\t///}\r\n\t\t\this._dndDroppable.destroy();\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\treturn Droppable;\r\n});"]}