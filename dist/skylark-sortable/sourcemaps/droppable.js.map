{"version":3,"sources":["droppable.js"],"names":["define","langx","finder","styler","eventer","noder","geom","touch","dnd","moved","pastFirstInvertThresh","isCircumstantialInvert","_silent","_unsilent","_index","el","selector","index","nodeName","toUpperCase","cloneEl","matches","[object Object]","sortable","options","this","_elm","elm","nativeDraggable","on","fromEl","toEl","dragEl","dragRect","targetEl","targetRect","originalEvt","willInsertAfter","evt","retVal","expando","onMoveFn","onMove","create","to","from","dragged","draggedRect","related","relatedRect","boundingRect","originalEvent","dispatchEvent","call","revert","lastMode","lastTarget","lastDirection","targetMoveDistance","target","group","activeSortable","active","isOwner","activeGroup","canSort","sort","rootEl","putSortable","nextEl","oldIndex","oldDraggableIndex","preventDefault","cancelable","closest","draggable","contains","animated","completed","disabled","lastPutMode","checkPull","checkPut","axis","_getDirection","_hideClone","parentEl","insertBefore","appendChild","elLastChild","lastChild","ignoreHidden","excluding","_lastChild","elRect","mouseOnAxis","clientY","clientX","mouseOnOppAxis","targetS2","bottom","right","targetS1Opp","left","top","targetS2Opp","_ghostIsLast","_showClone","_onMove","changed","parentNode","targetBeforeFirstSwap","direction","aligned","sortableMouseAligned","differentLevel","side1","el1","el2","el1Rect","el2Rect","el1S1Opp","el1S2Opp","el1OppLength","width","height","el2S1Opp","el2S2Opp","el2OppLength","_isElInRowColumn","invertSwap","swapThreshold","invertedSwapThreshold","isLastTarget","targetLength","targetS1","invert","_getInsertDirection","_getSwapDirection","nextSibling","nextElementSibling","after","moveVector","setTimeout","undefined","Math","abs","insertion","toggleClass","ghostClass","_animate","dragoverBubble","document","over","nearestEmptyInsertDetectEvent","stopPropagation","_dispatchEvent","newIndex","newDraggableIndex","off","_offUpEvents","dropBubble","remove","_disableDraggable","style","chosenClass","save","_nulling","ownerDocument","_onDrop","type","_onDragOver","dataTransfer","dropEffect","_globalDragOver"],"mappings":"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","file":"../droppable.js","sourcesContent":["define([\r\n\t\"skylark-langx\",\r\n\t\"skylark-domx-finder\",\r\n\t\"skylark-domx-styler\",\r\n\t\"skylark-domx-eventer\",\r\n\t\"skylark-domx-noder\",\r\n\t\"skylark-domx-geom\",\r\n\t\"skylark-devices-points/touch\",\r\n\t\"./dnd\"\r\n],function(langx,finder,styler,eventer,noder,geom,touch,dnd){\r\n\r\n\tvar\tmoved,\r\n\t    pastFirstInvertThresh,\r\n\t    isCircumstantialInvert,\r\n   \t\t_silent = false;\r\n\r\n\r\n\r\n\tfunction _unsilent() {\r\n\t\t_silent = false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\r\n\t * @param  {HTMLElement} el       Parent element\r\n\t * @return {HTMLElement}          The last child, ignoring ghostEl\r\n\t */\r\n\t function _lastChild(el) {\r\n\t\treturn finder.lastChild(el,{\r\n\t\t\tignoreHidden : true,\r\n\t\t\texcluding : []\r\n\t\t})\r\n\t}\r\n\r\n\t function _ghostIsLast(evt, axis, el) {\r\n\t\tvar elRect = geom.boundingRect(finder.lastChild(el,{ignoreHidden : true,excluding : []})),\r\n\t\t\tmouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,\r\n\t\t\tmouseOnOppAxis = axis === 'vertical' ? evt.clientX : evt.clientY,\r\n\t\t\ttargetS2 = axis === 'vertical' ? elRect.bottom : elRect.right,\r\n\t\t\ttargetS1Opp = axis === 'vertical' ? elRect.left : elRect.top,\r\n\t\t\ttargetS2Opp = axis === 'vertical' ? elRect.right : elRect.bottom,\r\n\t\t\tspacer = 10;\r\n\r\n\t\treturn (\r\n\t\t\taxis === 'vertical' ?\r\n\t\t\t\t(mouseOnOppAxis > targetS2Opp + spacer || mouseOnOppAxis <= targetS2Opp && mouseOnAxis > targetS2 && mouseOnOppAxis >= targetS1Opp) :\r\n\t\t\t\t(mouseOnAxis > targetS2 && mouseOnOppAxis > targetS1Opp || mouseOnAxis <= targetS2 && mouseOnOppAxis > targetS2Opp + spacer)\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tfunction _isClientInRowColumn(x, y, el, axis, options) {\r\n\t\tvar targetRect = geom.boundingRect(el),\r\n\t\t\ttargetS1Opp = axis === 'vertical' ? targetRect.left : targetRect.top,\r\n\t\t\ttargetS2Opp = axis === 'vertical' ? targetRect.right : targetRect.bottom,\r\n\t\t\tmouseOnOppAxis = axis === 'vertical' ? x : y;\r\n\r\n\t\treturn targetS1Opp < mouseOnOppAxis && mouseOnOppAxis < targetS2Opp;\r\n\t}\r\n\r\n\tfunction _isElInRowColumn(el1, el2, axis) {\r\n\t\t//var dragEl = dnd.active.dragEl;\r\n\r\n\t\tvar el1Rect = geom.boundingRect(el1),//el1 === dragEl && realDragElRect || geom.boundingRect(el1),\r\n\t\t\tel2Rect = geom.boundingRect(el2),//el2 === dragEl && realDragElRect || geom.boundingRect(el2),\r\n\t\t\tel1S1Opp = axis === 'vertical' ? el1Rect.left : el1Rect.top,\r\n\t\t\tel1S2Opp = axis === 'vertical' ? el1Rect.right : el1Rect.bottom,\r\n\t\t\tel1OppLength = axis === 'vertical' ? el1Rect.width : el1Rect.height,\r\n\t\t\tel2S1Opp = axis === 'vertical' ? el2Rect.left : el2Rect.top,\r\n\t\t\tel2S2Opp = axis === 'vertical' ? el2Rect.right : el2Rect.bottom,\r\n\t\t\tel2OppLength = axis === 'vertical' ? el2Rect.width : el2Rect.height;\r\n\r\n\t\treturn (\r\n\t\t\tel1S1Opp === el2S1Opp ||\r\n\t\t\tel1S2Opp === el2S2Opp ||\r\n\t\t\t(el1S1Opp + el1OppLength / 2) === (el2S1Opp + el2OppLength / 2)\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the index of an element within its parent for a selected set of\r\n\t * elements\r\n\t * @param  {HTMLElement} el\r\n\t * @param  {selector} selector\r\n\t * @return {number}\r\n\t */\r\n\tfunction _index(el, selector) {\r\n\t\treturn finder.index(el,function(el){\r\n\t\t\tif ((el.nodeName.toUpperCase() !== 'TEMPLATE') && el !== dnd.cloneEl && (!selector || finder.matches(el, selector))) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\t\t\t\r\n\t\t})\r\n\t}\t\r\n\r\n    function _globalDragOver(/**Event*/evt) {\r\n\t\tif (evt.dataTransfer) {\r\n\t\t\tevt.dataTransfer.dropEffect = 'move';\r\n\t\t}\r\n\t\tevt.cancelable && evt.preventDefault();\r\n\t}\r\n\r\n\tclass Droppable {\r\n\t\tconstructor(sortable,options) {\r\n\t\t\tthis.sortable = sortable;\r\n\t\t\tvar el = this.el= this._elm = sortable.elm();\r\n\t\t\tthis.options = options;\r\n\r\n\t\t\tif (sortable.nativeDraggable) {\r\n\t\t\t\teventer.on(el, 'dragover', this);\r\n\t\t\t\teventer.on(el, 'dragenter', this);\r\n\t\t        eventer.on(el, 'drop', this);\r\n\t\t\t}\r\n\t        eventer.on(el, 'selectstart', this);\r\n\t\t}\r\n\r\n\r\n\t\t_onMove (fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {\r\n\t\t\tvar evt,\r\n\t\t\t\tsortable = fromEl[dnd.expando],\r\n\t\t\t\tonMoveFn = sortable.options.onMove,\r\n\t\t\t\tretVal;\r\n\r\n\t\t\tevt = eventer.create(\"move\",{\r\n\t\t\t\tto : toEl,\r\n\t\t\t\tfrom : fromEl,\r\n\t\t\t\tdragged : dragEl,\r\n\t\t\t\tdraggedRect: dragRect,\r\n\t\t\t\trelated : targetEl || toEl,\r\n\t\t\t\trelatedRect : targetRect || geom.boundingRect(toEl),\r\n\t\t\t\twillInsertAfter : willInsertAfter,\r\n\t\t\t\toriginalEvent : originalEvt\r\n\t\t\t});\r\n\r\n\t\t\tfromEl.dispatchEvent(evt);\r\n\r\n\t\t\tif (onMoveFn) {\r\n\t\t\t\tretVal = onMoveFn.call(sortable, evt, originalEvt);\r\n\t\t\t}\r\n\r\n\t\t\treturn retVal;\r\n\t\t}\r\n\r\n\r\n\t\t// Returns true - if no further action is needed (either inserted or another condition)\r\n\t\t_onDragOver(/**Event*/evt) {\r\n\t\t\tvar el = this._elm,\r\n\t\t\t\ttarget = evt.target,\r\n\t\t\t\tdragRect,\r\n\t\t\t\ttargetRect,\r\n\t\t\t\trevert,\r\n\t\t\t\toptions = this.options,\r\n\t\t\t\tgroup = options.group,\r\n\t\t\t\tactiveSortable = dnd.active,\r\n\t\t\t\tisOwner = (dnd.activeGroup === group),\r\n\t\t\t\tcanSort = options.sort,\r\n\t\t\t\tsortable = this.sortable,\r\n\t\t\t\tdragEl = dnd.dragEl,\r\n\t\t\t\trootEl = dnd.active.elm(),\r\n\t\t\t\tputSortable = dnd.putSortable,\r\n\t\t\t\tnextEl = dnd.nextEl,\r\n\t\t\t\toldIndex = dnd.oldIndex,\r\n\t\t\t\toldDraggableIndex = dnd.oldDraggableIndex,\r\n\r\n\t\t\t\tlastMode, // 'swap' or 'insert'\r\n\t\t\t\tlastTarget,\r\n\t\t\t\tlastDirection,\r\n\t\t\t\ttargetMoveDistance;\r\n            //dnd.log(\"_onDragOver\",\"start\");\r\n\r\n\t\t\tif (_silent) return;\r\n\r\n\t\t\t// Return invocation when dragEl is inserted (or completed)\r\n\t\t\tfunction completed(insertion) {\r\n\t\t\t\tif (insertion) {\r\n\t\t\t\t\tif (isOwner) {\r\n\t\t\t\t\t\tactiveSortable._hideClone();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tactiveSortable._showClone(sortable);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (activeSortable) {\r\n\t\t\t\t\t\t// Set ghost class to new sortable's ghost class\r\n\t\t\t\t\t\tstyler.toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\r\n\t\t\t\t\t\tstyler.toggleClass(dragEl, options.ghostClass, true);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (putSortable !== sortable && sortable !== dnd.active) {\r\n\t\t\t\t\t\tputSortable = dnd.putSortable = sortable;\r\n\t\t\t\t\t} else if (sortable === dnd.active) {\r\n\t\t\t\t\t\tputSortable = dnd.putSortable =  null;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Animation\r\n\t\t\t\t\tdragRect && sortable._animate(dragRect, dragEl);\r\n\t\t\t\t\ttarget && targetRect && sortable._animate(targetRect, target);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\t// Null lastTarget if it is not inside a previously swapped element\r\n\t\t\t\tif ((target === dragEl && !dragEl.animated) || (target === el && !target.animated)) {\r\n\t\t\t\t\tlastTarget = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// no bubbling and not fallback\r\n\t\t\t\tif (!options.dragoverBubble && !evt.rootEl && target !== document) {\r\n\t\t\t\t\t//sortable._handleAutoScroll(evt);\r\n\t\t\t\t\tdnd.over(evt);\r\n\r\n\t\t\t\t\t// Do not detect for empty insert if already inserted\r\n\t\t\t\t\t!insertion && dnd.nearestEmptyInsertDetectEvent(evt);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t!options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Call when dragEl has been inserted\r\n\t\t\tfunction changed() {\r\n\t\t\t\tsortable._dispatchEvent(sortable, rootEl, 'change', target, el, rootEl, oldIndex, _index(dragEl), oldDraggableIndex, _index(dragEl, options.draggable), evt);\r\n\t\t\t}\r\n\r\n\r\n\t\t\t/**\r\n\t\t\t * Gets the direction dragEl must be swapped relative to target in order to make it\r\n\t\t\t * seem that dragEl has been \"inserted\" into that element's position\r\n\t\t\t * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\r\n\t\t\t * @return {Number}                   Direction dragEl must be swapped\r\n\t\t\t */\r\n\t\t\tfunction _getInsertDirection(target) {\r\n\t\t\t\tvar dragElIndex = _index(dragEl),\r\n\t\t\t\t\ttargetIndex = _index(target);\r\n\r\n\t\t\t\tif (dragElIndex < targetIndex) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfunction _getSwapDirection(evt, target, axis, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\r\n\t\t\t\tvar targetRect = geom.boundingRect(target),\r\n\t\t\t\t\tmouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,\r\n\t\t\t\t\ttargetLength = axis === 'vertical' ? targetRect.height : targetRect.width,\r\n\t\t\t\t\ttargetS1 = axis === 'vertical' ? targetRect.top : targetRect.left,\r\n\t\t\t\t\ttargetS2 = axis === 'vertical' ? targetRect.bottom : targetRect.right,\r\n\t\t\t\t\tdragRect = geom.boundingRect(dragEl),\r\n\t\t\t\t\tinvert = false;\r\n\r\n\r\n\t\t\t\tif (!invertSwap) {\r\n\t\t\t\t\t// Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\r\n\t\t\t\t\tif (isLastTarget && targetMoveDistance < targetLength * swapThreshold) { // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\r\n\t\t\t\t\t\t// check if past first invert threshold on side opposite of lastDirection\r\n\t\t\t\t\t\tif (!pastFirstInvertThresh &&\r\n\t\t\t\t\t\t\t(lastDirection === 1 ?\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2\r\n\t\t\t\t\t\t\t\t) :\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// past first invert threshold, do not restrict inverted threshold to dragEl shadow\r\n\t\t\t\t\t\t\tpastFirstInvertThresh = true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!pastFirstInvertThresh) {\r\n\t\t\t\t\t\t\tvar dragS1 = axis === 'vertical' ? dragRect.top : dragRect.left,\r\n\t\t\t\t\t\t\t\tdragS2 = axis === 'vertical' ? dragRect.bottom : dragRect.right;\r\n\t\t\t\t\t\t\t// dragEl shadow (target move distance shadow)\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tlastDirection === 1 ?\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\r\n\t\t\t\t\t\t\t\t) :\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis > targetS2 - targetMoveDistance\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\treturn lastDirection * -1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tinvert = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Regular\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tmouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold) / 2) &&\r\n\t\t\t\t\t\t\tmouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold) / 2)\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\treturn _getInsertDirection(target);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinvert = invert || invertSwap;\r\n\r\n\t\t\t\tif (invert) {\r\n\t\t\t\t\t// Invert of regular\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tmouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold / 2) ||\r\n\t\t\t\t\t\tmouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold / 2)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn ((mouseOnAxis > targetS1 + targetLength / 2) ? 1 : -1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (evt.preventDefault !== void 0) {\r\n\t\t\t\tevt.cancelable && evt.preventDefault();\r\n\t\t\t}\r\n\r\n\r\n\t\t\tmoved = true;\r\n\r\n\t\t\ttarget = finder.closest(target, options.draggable, el, true);\r\n\r\n\t\t\t// target is dragEl or target is animated\r\n\t\t\tif (dragEl.contains(evt.target) || target.animated) {\r\n\t\t\t\treturn completed(false);\r\n\t\t\t}\r\n\r\n\t\t\tif (activeSortable && !options.disabled &&\r\n\t\t\t\t(isOwner\r\n\t\t\t\t\t? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\r\n\t\t\t\t\t: (\r\n\t\t\t\t\t\tputSortable === this ||\r\n\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t(this.lastPutMode = dnd.activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&\r\n\t\t\t\t\t\t\tgroup.checkPut(this, activeSortable, dragEl, evt)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t) {\r\n\t\t\t\tvar axis = sortable._getDirection(evt, target);\r\n\r\n\t\t\t\tdragRect = geom.boundingRect(dragEl);\r\n\r\n\t\t\t\tif (revert) {\r\n\t\t\t\t\tthis._hideClone();\r\n\t\t\t\t\tdnd.parentEl = rootEl; // actualization\r\n\r\n\t\t\t\t\tif (nextEl) {\r\n\t\t\t\t\t\trootEl.insertBefore(dragEl, nextEl);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\trootEl.appendChild(dragEl);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn completed(true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar elLastChild = _lastChild(el);\r\n\r\n\t\t\t\tif (!elLastChild || _ghostIsLast(evt, axis, el) && !elLastChild.animated) {\r\n\t\t\t\t\t// assign target only if condition is true\r\n\t\t\t\t\tif (elLastChild && el === evt.target) {\r\n\t\t\t\t\t\ttarget = elLastChild;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (target) {\r\n\t\t\t\t\t\ttargetRect = geom.boundingRect(target);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (isOwner) {\r\n\t\t\t\t\t\tactiveSortable._hideClone();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tactiveSortable._showClone(this);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (this._onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\r\n\t\t\t\t\t\tel.appendChild(dragEl);\r\n\t\t\t\t\t\tdnd.parentEl = el; // actualization\r\n\t\t\t\t\t\t///realDragElRect = null;\r\n\r\n\t\t\t\t\t\tchanged();\r\n\t\t\t\t\t\treturn completed(true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (target && target !== dragEl && target.parentNode === el) {\r\n\t\t\t\t\tvar direction = 0,\r\n\t\t\t\t\t\ttargetBeforeFirstSwap,\r\n\t\t\t\t\t\taligned = target.sortableMouseAligned,\r\n\t\t\t\t\t\tdifferentLevel = dragEl.parentNode !== el,\r\n\t\t\t\t\t\tside1 = axis === 'vertical' ? 'top' : 'left',\r\n\t\t\t\t\t\tscrolledPastTop = false, //autoscroll._isScrolledPast(target, 'top') || autoscroll._isScrolledPast(dragEl, 'top'),\r\n\t\t\t\t\t\tscrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\r\n\r\n\r\n\t\t\t\t\tif (lastTarget !== target) {\r\n\t\t\t\t\t\tlastMode = null;\r\n\t\t\t\t\t\ttargetBeforeFirstSwap = geom.boundingRect(target)[side1];\r\n\t\t\t\t\t\tpastFirstInvertThresh = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Reference: https://www.lucidchart.com/documents/view/10fa0e93-e362-4126-aca2-b709ee56bd8b/0\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\t_isElInRowColumn(dragEl, target, axis) && aligned ||\r\n\t\t\t\t\t\tdifferentLevel ||\r\n\t\t\t\t\t\tscrolledPastTop ||\r\n\t\t\t\t\t\toptions.invertSwap ||\r\n\t\t\t\t\t\tlastMode === 'insert' ||\r\n\t\t\t\t\t\t// Needed, in the case that we are inside target and inserted because not aligned... aligned will stay false while inside\r\n\t\t\t\t\t\t// and lastMode will change to 'insert', but we must swap\r\n\t\t\t\t\t\tlastMode === 'swap'\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\t// New target that we will be inside\r\n\t\t\t\t\t\tif (lastMode !== 'swap') {\r\n\t\t\t\t\t\t\tisCircumstantialInvert = options.invertSwap || differentLevel;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdirection = _getSwapDirection(evt, target, axis,\r\n\t\t\t\t\t\t\toptions.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold,\r\n\t\t\t\t\t\t\tisCircumstantialInvert,\r\n\t\t\t\t\t\t\tlastTarget === target);\r\n\t\t\t\t\t\tlastMode = 'swap';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Insert at position\r\n\t\t\t\t\t\tdirection = _getInsertDirection(target);\r\n\t\t\t\t\t\tlastMode = 'insert';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (direction === 0) return completed(false);\r\n\r\n\t\t\t\t\t///realDragElRect = null;\r\n\t\t\t\t\tlastTarget = target;\r\n\r\n\t\t\t\t\tlastDirection = direction;\r\n\r\n\t\t\t\t\ttargetRect = geom.boundingRect(target);\r\n\r\n\t\t\t\t\tvar nextSibling = target.nextElementSibling,\r\n\t\t\t\t\t\tafter = false;\r\n\r\n\t\t\t\t\tafter = direction === 1;\r\n\r\n\t\t\t\t\tvar moveVector = this._onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\r\n\r\n\t\t\t\t\tif (moveVector !== false) {\r\n\t\t\t\t\t\tif (moveVector === 1 || moveVector === -1) {\r\n\t\t\t\t\t\t\tafter = (moveVector === 1);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_silent = true;\r\n\t\t\t\t\t\tsetTimeout(_unsilent, 30);\r\n\r\n\t\t\t\t\t\tif (isOwner) {\r\n\t\t\t\t\t\t\tactiveSortable._hideClone();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tactiveSortable._showClone(this);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (after && !nextSibling) {\r\n\t\t\t\t\t\t\tel.appendChild(dragEl);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttarget.parentNode.insertBefore(dragEl, after ? nextSibling : target);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Undo chrome's scroll adjustment\r\n\t\t\t\t\t\tif (scrolledPastTop) {\r\n\t\t\t\t\t\t\tgeom.scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdnd.parentEl = dragEl.parentNode; // actualization\r\n\r\n\t\t\t\t\t\t// must be done before animation\r\n\t\t\t\t\t\tif (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\r\n\t\t\t\t\t\t\ttargetMoveDistance =  Math.abs(targetBeforeFirstSwap - geom.boundingRect(target)[side1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tchanged();\r\n\r\n\t\t\t\t\t\treturn completed(true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (el.contains(dragEl)) {\r\n\t\t\t\t\treturn completed(false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t_onDrop(/**Event*/evt) {\r\n\t\t\tvar el = this.el,\r\n\t\t\t\toptions = this.options,\r\n\t\t\t\tsortable = this.sortable,\r\n\t\t\t\trootEl = dnd.active.elm(),\r\n\t\t\t\tdragEl = dnd.dragEl,\r\n\t\t\t\tputSortable = dnd.putSortable,\r\n\t\t\t\tparentEl = dnd.parentEl,\r\n\t\t\t\toldIndex = dnd.oldIndex,\r\n\t\t\t\toldDraggableIndex = dnd.oldDraggableIndex,\r\n\t\t\t\tnextEl = dnd.nextEl,\r\n\t\t\t\tnewIndex,\r\n\t\t\t\tnewDraggableIndex;\r\n\r\n\r\n\t\t\tisCircumstantialInvert = false;\r\n\t\t\tpastFirstInvertThresh = false;\r\n\r\n\r\n\t\t\tif (sortable.nativeDraggable) {\r\n\t\t\t\teventer.off(document, 'drop', this);\r\n\t\t\t}\r\n\r\n\t\t\tthis._offUpEvents();\r\n\r\n\t\t\tif (evt) {\r\n\t\t\t\tif (moved) {\r\n\t\t\t\t\tevt.cancelable && evt.preventDefault();\r\n\t\t\t\t\t!options.dropBubble && evt.stopPropagation();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//ghoster.remove();\r\n\r\n\t\t\t\tif (rootEl === parentEl || (putSortable && putSortable.lastPutMode !== 'clone')) {\r\n\t\t\t\t\t// Remove clone\r\n\t\t\t\t\tnoder.remove(dnd.cloneEl);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (dragEl) {\r\n\r\n\t\t\t\t\tdnd._disableDraggable(dragEl);\r\n\t\t\t\t\tdragEl.style['will-change'] = '';\r\n\r\n\t\t\t\t\t// Remove class'sd\r\n\t\t\t\t\tstyler.toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\r\n\t\t\t\t\tstyler.toggleClass(dragEl, this.options.chosenClass, false);\r\n\r\n\t\t\t\t\t// Drag stop event\r\n\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'unchoose', dragEl, parentEl, rootEl, oldIndex, null, oldDraggableIndex, null, evt);\r\n\r\n\t\t\t\t\tif (rootEl !== parentEl) {\r\n\t\t\t\t\t\tnewIndex = _index(dragEl);\r\n\t\t\t\t\t\tnewDraggableIndex = _index(dragEl, options.draggable);\r\n\r\n\t\t\t\t\t\tif (newIndex >= 0) {\r\n\t\t\t\t\t\t\t// Add event\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(null, parentEl, 'add', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\r\n\t\t\t\t\t\t\t// Remove event\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'remove', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\r\n\t\t\t\t\t\t\t// drag from one list and drop into another\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(null, parentEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tputSortable && putSortable.save();\r\n\t\t\t\t\t}else {\r\n\t\t\t\t\t\tif (dragEl.nextSibling !== nextEl) {\r\n\t\t\t\t\t\t\t// Get the index of the dragged element within its parent\r\n\t\t\t\t\t\t\tnewIndex = _index(dragEl);\r\n\t\t\t\t\t\t\tnewDraggableIndex = _index(dragEl, options.draggable);\r\n\r\n\t\t\t\t\t\t\tif (newIndex >= 0) {\r\n\t\t\t\t\t\t\t\t// drag & drop within the same list\r\n\t\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'update', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (dnd.active) {\r\n\t\t\t\t\t\t/* jshint eqnull:true */\r\n\t\t\t\t\t\tif (newIndex == null || newIndex === -1) {\r\n\t\t\t\t\t\t\tnewIndex = oldIndex;\r\n\t\t\t\t\t\t\tnewDraggableIndex = oldDraggableIndex;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'end', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\r\n\t\t\t\t\t\t// Save sorting\r\n\t\t\t\t\t\tsortable.save();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tthis._nulling();\r\n\t\t}\r\n\r\n\t\t_offUpEvents () {\r\n\t\t\tvar ownerDocument = this.el.ownerDocument;\r\n\r\n\t\t\teventer.off(ownerDocument, 'mouseup', this._onDrop);\r\n\t\t\teventer.off(document, 'selectstart', this);\r\n\t\t}\r\n\r\n\t\t_nulling() {\r\n\r\n\t\t\tmoved =\tnull;\r\n\r\n\t\t}\r\n\r\n\t\thandleEvent (/**Event*/evt) {\r\n\t\t\tswitch (evt.type) {\r\n\t\t\t\tcase 'drop':\r\n\t\t\t\t\tthis._onDrop(evt);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'dragenter':\r\n\t\t\t\tcase 'dragover':\r\n\t\t\t\t\tif (dnd.dragEl) {\r\n\t\t\t\t\t\tthis._onDragOver(evt);\r\n\t\t\t\t\t\t_globalDragOver(evt);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'selectstart':\r\n\t\t\t\t\tevt.preventDefault();\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\treturn Droppable;\r\n});"]}