{"version":3,"sources":["droppable.js"],"names":["define","langx","finder","styler","eventer","noder","geom","DndDroppable","dnd","moved","pastFirstInvertThresh","isCircumstantialInvert","_silent","_isScrolledPast","el","side","parent","scrollableParent","elSide","boundingRect","parentSide","scrollingElement","_unsilent","_index","selector","index","nodeName","toUpperCase","cloneEl","matches","_globalDragOver","evt","dataTransfer","dropEffect","cancelable","preventDefault","[object Object]","sortable","options","this","_elm","elm","self","_dndDroppable","started","e","acceptable","activeClass","hoverClass","overing","dragEl","_onDragOver","originalEvent","dropped","_onDrop","on","fromEl","toEl","dragRect","targetEl","targetRect","originalEvt","willInsertAfter","retVal","expando","onMoveFn","onMove","create","to","from","dragged","draggedRect","related","relatedRect","dispatchEvent","call","revert","lastMode","lastTarget","lastDirection","targetMoveDistance","target","group","activeSortable","active","isOwner","activeGroup","canSort","sort","rootEl","putSortable","nextEl","oldIndex","oldDraggableIndex","closest","draggable","contains","animated","completed","disabled","lastPutMode","checkPull","checkPut","axis","_getDirection","_hideClone","parentEl","insertBefore","appendChild","elLastChild","lastChild","ignoreHidden","excluding","_lastChild","elRect","mouseOnAxis","clientY","clientX","mouseOnOppAxis","targetS2","bottom","right","targetS1Opp","left","top","targetS2Opp","_ghostIsLast","_showClone","_onMove","changed","parentNode","targetBeforeFirstSwap","direction","aligned","sortableMouseAligned","differentLevel","side1","scrolledPastTop","scrollBefore","scrollTop","el1","el2","el1Rect","el2Rect","el1S1Opp","el1S2Opp","el1OppLength","width","height","el2S1Opp","el2S2Opp","el2OppLength","_isElInRowColumn","invertSwap","swapThreshold","invertedSwapThreshold","isLastTarget","targetLength","targetS1","invert","_getInsertDirection","_getSwapDirection","nextSibling","nextElementSibling","after","moveVector","setTimeout","scrollBy","undefined","Math","abs","insertion","toggleClass","ghostClass","_animate","dragoverBubble","document","over","nearestEmptyInsertDetectEvent","stopPropagation","_dispatchEvent","newIndex","newDraggableIndex","nativeDraggable","off","_offUpEvents","dropBubble","remove","_disableDraggable","style","chosenClass","save","_nulling","ownerDocument","type","his","destroy"],"mappings":"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","file":"../droppable.js","sourcesContent":["define([\r\n\t\"skylark-langx\",\r\n\t\"skylark-domx-finder\",\r\n\t\"skylark-domx-styler\",\r\n\t\"skylark-domx-eventer\",\r\n\t\"skylark-domx-noder\",\r\n\t\"skylark-domx-geom\",\r\n    \"skylark-domx-plugins-dnd/droppable\",\r\n\t\"./dnd\"\r\n],function(langx,finder,styler,eventer,noder,geom,DndDroppable,dnd){\r\n\r\n\tvar\tmoved,\r\n\t    pastFirstInvertThresh,\r\n\t    isCircumstantialInvert,\r\n   \t\t_silent = false;\r\n\r\n\r\n\t/**\r\n\t * Checks if a side of an element is scrolled past a side of it's parents\r\n\t * @param  {HTMLElement}  el       The element who's side being scrolled out of view is in question\r\n\t * @param  {String}       side     Side of the element in question ('top', 'left', 'right', 'bottom')\r\n\t * @return {HTMLElement}           The parent scroll element that the el's side is scrolled past, or null if there is no such element\r\n\t */\r\n\tfunction _isScrolledPast(el, side) {\r\n\t\tvar parent = finder.scrollableParent(el, true),\r\n\t\t\telSide = geom.boundingRect(el)[side];\r\n\r\n\t\t/* jshint boss:true */\r\n\t\twhile (parent) {\r\n\t\t\tvar parentSide = geom.boundingRect(parent)[side],\r\n\t\t\t\tvisible;\r\n\r\n\t\t\tif (side === 'top' || side === 'left') {\r\n\t\t\t\tvisible = elSide >= parentSide;\r\n\t\t\t} else {\r\n\t\t\t\tvisible = elSide <= parentSide;\r\n\t\t\t}\r\n\r\n\t\t\tif (!visible) return parent;\r\n\r\n\t\t\tif (parent === noder.scrollingElement()) break;\r\n\r\n\t\t\tparent = finder.scrollableParent(parent, false);\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\r\n\tfunction _unsilent() {\r\n\t\t_silent = false;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\r\n\t * @param  {HTMLElement} el       Parent element\r\n\t * @return {HTMLElement}          The last child, ignoring ghostEl\r\n\t */\r\n\t function _lastChild(el) {\r\n\t\treturn finder.lastChild(el,{\r\n\t\t\tignoreHidden : true,\r\n\t\t\texcluding : []\r\n\t\t})\r\n\t}\r\n\r\n\t function _ghostIsLast(evt, axis, el) {\r\n\t\tvar elRect = geom.boundingRect(finder.lastChild(el,{ignoreHidden : true,excluding : []})),\r\n\t\t\tmouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,\r\n\t\t\tmouseOnOppAxis = axis === 'vertical' ? evt.clientX : evt.clientY,\r\n\t\t\ttargetS2 = axis === 'vertical' ? elRect.bottom : elRect.right,\r\n\t\t\ttargetS1Opp = axis === 'vertical' ? elRect.left : elRect.top,\r\n\t\t\ttargetS2Opp = axis === 'vertical' ? elRect.right : elRect.bottom,\r\n\t\t\tspacer = 10;\r\n\r\n\t\treturn (\r\n\t\t\taxis === 'vertical' ?\r\n\t\t\t\t(mouseOnOppAxis > targetS2Opp + spacer || mouseOnOppAxis <= targetS2Opp && mouseOnAxis > targetS2 && mouseOnOppAxis >= targetS1Opp) :\r\n\t\t\t\t(mouseOnAxis > targetS2 && mouseOnOppAxis > targetS1Opp || mouseOnAxis <= targetS2 && mouseOnOppAxis > targetS2Opp + spacer)\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tfunction _isClientInRowColumn(x, y, el, axis, options) {\r\n\t\tvar targetRect = geom.boundingRect(el),\r\n\t\t\ttargetS1Opp = axis === 'vertical' ? targetRect.left : targetRect.top,\r\n\t\t\ttargetS2Opp = axis === 'vertical' ? targetRect.right : targetRect.bottom,\r\n\t\t\tmouseOnOppAxis = axis === 'vertical' ? x : y;\r\n\r\n\t\treturn targetS1Opp < mouseOnOppAxis && mouseOnOppAxis < targetS2Opp;\r\n\t}\r\n\r\n\tfunction _isElInRowColumn(el1, el2, axis) {\r\n\t\t//var dragEl = dnd.active.dragEl;\r\n\r\n\t\tvar el1Rect = geom.boundingRect(el1),//el1 === dragEl && realDragElRect || geom.boundingRect(el1),\r\n\t\t\tel2Rect = geom.boundingRect(el2),//el2 === dragEl && realDragElRect || geom.boundingRect(el2),\r\n\t\t\tel1S1Opp = axis === 'vertical' ? el1Rect.left : el1Rect.top,\r\n\t\t\tel1S2Opp = axis === 'vertical' ? el1Rect.right : el1Rect.bottom,\r\n\t\t\tel1OppLength = axis === 'vertical' ? el1Rect.width : el1Rect.height,\r\n\t\t\tel2S1Opp = axis === 'vertical' ? el2Rect.left : el2Rect.top,\r\n\t\t\tel2S2Opp = axis === 'vertical' ? el2Rect.right : el2Rect.bottom,\r\n\t\t\tel2OppLength = axis === 'vertical' ? el2Rect.width : el2Rect.height;\r\n\r\n\t\treturn (\r\n\t\t\tel1S1Opp === el2S1Opp ||\r\n\t\t\tel1S2Opp === el2S2Opp ||\r\n\t\t\t(el1S1Opp + el1OppLength / 2) === (el2S1Opp + el2OppLength / 2)\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the index of an element within its parent for a selected set of\r\n\t * elements\r\n\t * @param  {HTMLElement} el\r\n\t * @param  {selector} selector\r\n\t * @return {number}\r\n\t */\r\n\tfunction _index(el, selector) {\r\n\t\treturn finder.index(el,function(el){\r\n\t\t\tif ((el.nodeName.toUpperCase() !== 'TEMPLATE') && el !== dnd.cloneEl && (!selector || finder.matches(el, selector))) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\t\t\t\r\n\t\t})\r\n\t}\t\r\n\r\n    function _globalDragOver(/**Event*/evt) {\r\n\t\tif (evt.dataTransfer) {\r\n\t\t\tevt.dataTransfer.dropEffect = 'move';\r\n\t\t}\r\n\t\tevt.cancelable && evt.preventDefault();\r\n\t}\r\n\r\n\tclass Droppable {\r\n\t\tconstructor(sortable,options) {\r\n\t\t\tthis.sortable = sortable;\r\n\t\t\tvar el = this.el= this._elm = sortable.elm();\r\n\t\t\tthis.options = options;\r\n\r\n\r\n\t\t\tvar self = this;\r\n\r\n            this._dndDroppable = new DndDroppable(el,{\r\n\t            started: function(e) {\r\n\t                e.acceptable = true;\r\n\t                e.activeClass = \"active\";\r\n\t                e.hoverClass = \"over\";\r\n\t            },\r\n\r\n                overing : function(e) {\r\n\t\t\t\t\tif (dnd.dragEl) {\r\n\t\t\t\t\t\tself._onDragOver(e.originalEvent);\r\n\t\t\t\t\t\t_globalDragOver(e.originalEvent);\r\n\t\t\t\t\t}\r\n                },\r\n\r\n\r\n                dropped : function(e) {\r\n                    self._onDrop(e.originalEvent);\r\n                }\r\n            });\r\n\r\n\r\n\r\n\t\t\t///if (sortable.nativeDraggable) {\r\n\t\t\t///\teventer.on(el, 'dragover', this);\r\n\t\t\t///\teventer.on(el, 'dragenter', this);\r\n\t\t        eventer.on(el, 'drop', this);\r\n\t\t\t///}\r\n\t        eventer.on(el, 'selectstart', this);\r\n\t\t}\r\n\r\n\r\n\t\t_onMove (fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvt, willInsertAfter) {\r\n\t\t\tvar evt,\r\n\t\t\t\tsortable = fromEl[dnd.expando],\r\n\t\t\t\tonMoveFn = sortable.options.onMove,\r\n\t\t\t\tretVal;\r\n\r\n\t\t\tevt = eventer.create(\"move\",{\r\n\t\t\t\tto : toEl,\r\n\t\t\t\tfrom : fromEl,\r\n\t\t\t\tdragged : dragEl,\r\n\t\t\t\tdraggedRect: dragRect,\r\n\t\t\t\trelated : targetEl || toEl,\r\n\t\t\t\trelatedRect : targetRect || geom.boundingRect(toEl),\r\n\t\t\t\twillInsertAfter : willInsertAfter,\r\n\t\t\t\toriginalEvent : originalEvt\r\n\t\t\t});\r\n\r\n\t\t\tfromEl.dispatchEvent(evt);\r\n\r\n\t\t\tif (onMoveFn) {\r\n\t\t\t\tretVal = onMoveFn.call(sortable, evt, originalEvt);\r\n\t\t\t}\r\n\r\n\t\t\treturn retVal;\r\n\t\t}\r\n\r\n\r\n\t\t// Returns true - if no further action is needed (either inserted or another condition)\r\n\t\t_onDragOver(/**Event*/evt) {\r\n\t\t\tvar el = this._elm,\r\n\t\t\t\ttarget = evt.target,\r\n\t\t\t\tdragRect,\r\n\t\t\t\ttargetRect,\r\n\t\t\t\trevert,\r\n\t\t\t\toptions = this.options,\r\n\t\t\t\tgroup = options.group,\r\n\t\t\t\tactiveSortable = dnd.active,\r\n\t\t\t\tisOwner = (dnd.activeGroup === group),\r\n\t\t\t\tcanSort = options.sort,\r\n\t\t\t\tsortable = this.sortable,\r\n\t\t\t\tdragEl = dnd.dragEl,\r\n\t\t\t\trootEl = dnd.active.elm(),\r\n\t\t\t\tputSortable = dnd.putSortable,\r\n\t\t\t\tnextEl = dnd.nextEl,\r\n\t\t\t\toldIndex = dnd.oldIndex,\r\n\t\t\t\toldDraggableIndex = dnd.oldDraggableIndex,\r\n\r\n\t\t\t\tlastMode, // 'swap' or 'insert'\r\n\t\t\t\tlastTarget,\r\n\t\t\t\tlastDirection,\r\n\t\t\t\ttargetMoveDistance;\r\n            //dnd.log(\"_onDragOver\",\"start\");\r\n\r\n\t\t\tif (_silent) return;\r\n\r\n\t\t\t// Return invocation when dragEl is inserted (or completed)\r\n\t\t\tfunction completed(insertion) {\r\n\t\t\t\tif (insertion) {\r\n\t\t\t\t\tif (isOwner) {\r\n\t\t\t\t\t\tactiveSortable._hideClone();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tactiveSortable._showClone(sortable);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (activeSortable) {\r\n\t\t\t\t\t\t// Set ghost class to new sortable's ghost class\r\n\t\t\t\t\t\tstyler.toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);\r\n\t\t\t\t\t\tstyler.toggleClass(dragEl, options.ghostClass, true);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (putSortable !== sortable && sortable !== dnd.active) {\r\n\t\t\t\t\t\tputSortable = dnd.putSortable = sortable;\r\n\t\t\t\t\t} else if (sortable === dnd.active) {\r\n\t\t\t\t\t\tputSortable = dnd.putSortable =  null;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Animation\r\n\t\t\t\t\tdragRect && sortable._animate(dragRect, dragEl);\r\n\t\t\t\t\ttarget && targetRect && sortable._animate(targetRect, target);\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\t// Null lastTarget if it is not inside a previously swapped element\r\n\t\t\t\tif ((target === dragEl && !dragEl.animated) || (target === el && !target.animated)) {\r\n\t\t\t\t\tlastTarget = null;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// no bubbling and not fallback\r\n\t\t\t\tif (!options.dragoverBubble && !evt.rootEl && target !== document) {\r\n\t\t\t\t\t//sortable._handleAutoScroll(evt);\r\n\t\t\t\t\tdnd.over(evt);\r\n\r\n\t\t\t\t\t// Do not detect for empty insert if already inserted\r\n\t\t\t\t\t!insertion && dnd.nearestEmptyInsertDetectEvent(evt);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t!options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();\r\n\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// Call when dragEl has been inserted\r\n\t\t\tfunction changed() {\r\n\t\t\t\tsortable._dispatchEvent(sortable, rootEl, 'change', target, el, rootEl, oldIndex, _index(dragEl), oldDraggableIndex, _index(dragEl, options.draggable), evt);\r\n\t\t\t}\r\n\r\n\r\n\t\t\t/**\r\n\t\t\t * Gets the direction dragEl must be swapped relative to target in order to make it\r\n\t\t\t * seem that dragEl has been \"inserted\" into that element's position\r\n\t\t\t * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\r\n\t\t\t * @return {Number}                   Direction dragEl must be swapped\r\n\t\t\t */\r\n\t\t\tfunction _getInsertDirection(target) {\r\n\t\t\t\tvar dragElIndex = _index(dragEl),\r\n\t\t\t\t\ttargetIndex = _index(target);\r\n\r\n\t\t\t\tif (dragElIndex < targetIndex) {\r\n\t\t\t\t\treturn 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn -1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\r\n\t\t\tfunction _getSwapDirection(evt, target, axis, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {\r\n\t\t\t\tvar targetRect = geom.boundingRect(target),\r\n\t\t\t\t\tmouseOnAxis = axis === 'vertical' ? evt.clientY : evt.clientX,\r\n\t\t\t\t\ttargetLength = axis === 'vertical' ? targetRect.height : targetRect.width,\r\n\t\t\t\t\ttargetS1 = axis === 'vertical' ? targetRect.top : targetRect.left,\r\n\t\t\t\t\ttargetS2 = axis === 'vertical' ? targetRect.bottom : targetRect.right,\r\n\t\t\t\t\tdragRect = geom.boundingRect(dragEl),\r\n\t\t\t\t\tinvert = false;\r\n\r\n\r\n\t\t\t\tif (!invertSwap) {\r\n\t\t\t\t\t// Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold\r\n\t\t\t\t\tif (isLastTarget && targetMoveDistance < targetLength * swapThreshold) { // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2\r\n\t\t\t\t\t\t// check if past first invert threshold on side opposite of lastDirection\r\n\t\t\t\t\t\tif (!pastFirstInvertThresh &&\r\n\t\t\t\t\t\t\t(lastDirection === 1 ?\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2\r\n\t\t\t\t\t\t\t\t) :\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// past first invert threshold, do not restrict inverted threshold to dragEl shadow\r\n\t\t\t\t\t\t\tpastFirstInvertThresh = true;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (!pastFirstInvertThresh) {\r\n\t\t\t\t\t\t\tvar dragS1 = axis === 'vertical' ? dragRect.top : dragRect.left,\r\n\t\t\t\t\t\t\t\tdragS2 = axis === 'vertical' ? dragRect.bottom : dragRect.right;\r\n\t\t\t\t\t\t\t// dragEl shadow (target move distance shadow)\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tlastDirection === 1 ?\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow\r\n\t\t\t\t\t\t\t\t) :\r\n\t\t\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t\t\tmouseOnAxis > targetS2 - targetMoveDistance\r\n\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\treturn lastDirection * -1;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tinvert = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Regular\r\n\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\tmouseOnAxis > targetS1 + (targetLength * (1 - swapThreshold) / 2) &&\r\n\t\t\t\t\t\t\tmouseOnAxis < targetS2 - (targetLength * (1 - swapThreshold) / 2)\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\treturn _getInsertDirection(target);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tinvert = invert || invertSwap;\r\n\r\n\t\t\t\tif (invert) {\r\n\t\t\t\t\t// Invert of regular\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\tmouseOnAxis < targetS1 + (targetLength * invertedSwapThreshold / 2) ||\r\n\t\t\t\t\t\tmouseOnAxis > targetS2 - (targetLength * invertedSwapThreshold / 2)\r\n\t\t\t\t\t)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn ((mouseOnAxis > targetS1 + targetLength / 2) ? 1 : -1);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (evt.preventDefault !== void 0) {\r\n\t\t\t\tevt.cancelable && evt.preventDefault();\r\n\t\t\t}\r\n\r\n\r\n\t\t\tmoved = true;\r\n\r\n\t\t\ttarget = finder.closest(target, options.draggable, el, true);\r\n\r\n\t\t\t// target is dragEl or target is animated\r\n\t\t\tif (dragEl.contains(evt.target) || target.animated) {\r\n\t\t\t\treturn completed(false);\r\n\t\t\t}\r\n\r\n\t\t\tif (activeSortable && !options.disabled &&\r\n\t\t\t\t(isOwner\r\n\t\t\t\t\t? canSort || (revert = !rootEl.contains(dragEl)) // Reverting item into the original list\r\n\t\t\t\t\t: (\r\n\t\t\t\t\t\tputSortable === this ||\r\n\t\t\t\t\t\t(\r\n\t\t\t\t\t\t\t(this.lastPutMode = dnd.activeGroup.checkPull(this, activeSortable, dragEl, evt)) &&\r\n\t\t\t\t\t\t\tgroup.checkPut(this, activeSortable, dragEl, evt)\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t)\r\n\t\t\t\t)\r\n\t\t\t) {\r\n\t\t\t\tvar axis = sortable._getDirection(evt, target);\r\n\r\n\t\t\t\tdragRect = geom.boundingRect(dragEl);\r\n\r\n\t\t\t\tif (revert) {\r\n\t\t\t\t\tthis._hideClone();\r\n\t\t\t\t\tdnd.parentEl = rootEl; // actualization\r\n\r\n\t\t\t\t\tif (nextEl) {\r\n\t\t\t\t\t\trootEl.insertBefore(dragEl, nextEl);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\trootEl.appendChild(dragEl);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn completed(true);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar elLastChild = _lastChild(el);\r\n\r\n\t\t\t\tif (!elLastChild || _ghostIsLast(evt, axis, el) && !elLastChild.animated) {\r\n\t\t\t\t\t// assign target only if condition is true\r\n\t\t\t\t\tif (elLastChild && el === evt.target) {\r\n\t\t\t\t\t\ttarget = elLastChild;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (target) {\r\n\t\t\t\t\t\ttargetRect = geom.boundingRect(target);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (isOwner) {\r\n\t\t\t\t\t\tactiveSortable._hideClone();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tactiveSortable._showClone(this);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (this._onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {\r\n\t\t\t\t\t\tel.appendChild(dragEl);\r\n\t\t\t\t\t\tdnd.parentEl = el; // actualization\r\n\t\t\t\t\t\t///realDragElRect = null;\r\n\r\n\t\t\t\t\t\tchanged();\r\n\t\t\t\t\t\treturn completed(true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse if (target && target !== dragEl && target.parentNode === el) {\r\n\t\t\t\t\tvar direction = 0,\r\n\t\t\t\t\t\ttargetBeforeFirstSwap,\r\n\t\t\t\t\t\taligned = target.sortableMouseAligned,\r\n\t\t\t\t\t\tdifferentLevel = dragEl.parentNode !== el,\r\n\t\t\t\t\t\tside1 = axis === 'vertical' ? 'top' : 'left',\r\n\t\t\t\t\t\tscrolledPastTop = _isScrolledPast(target, 'top') || _isScrolledPast(dragEl, 'top'),\r\n\t\t\t\t\t\tscrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;\r\n\r\n\r\n\t\t\t\t\tif (lastTarget !== target) {\r\n\t\t\t\t\t\tlastMode = null;\r\n\t\t\t\t\t\ttargetBeforeFirstSwap = geom.boundingRect(target)[side1];\r\n\t\t\t\t\t\tpastFirstInvertThresh = false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Reference: https://www.lucidchart.com/documents/view/10fa0e93-e362-4126-aca2-b709ee56bd8b/0\r\n\t\t\t\t\tif (\r\n\t\t\t\t\t\t_isElInRowColumn(dragEl, target, axis) && aligned ||\r\n\t\t\t\t\t\tdifferentLevel ||\r\n\t\t\t\t\t\tscrolledPastTop ||\r\n\t\t\t\t\t\toptions.invertSwap ||\r\n\t\t\t\t\t\tlastMode === 'insert' ||\r\n\t\t\t\t\t\t// Needed, in the case that we are inside target and inserted because not aligned... aligned will stay false while inside\r\n\t\t\t\t\t\t// and lastMode will change to 'insert', but we must swap\r\n\t\t\t\t\t\tlastMode === 'swap'\r\n\t\t\t\t\t) {\r\n\t\t\t\t\t\t// New target that we will be inside\r\n\t\t\t\t\t\tif (lastMode !== 'swap') {\r\n\t\t\t\t\t\t\tisCircumstantialInvert = options.invertSwap || differentLevel;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdirection = _getSwapDirection(evt, target, axis,\r\n\t\t\t\t\t\t\toptions.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold,\r\n\t\t\t\t\t\t\tisCircumstantialInvert,\r\n\t\t\t\t\t\t\tlastTarget === target);\r\n\t\t\t\t\t\tlastMode = 'swap';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// Insert at position\r\n\t\t\t\t\t\tdirection = _getInsertDirection(target);\r\n\t\t\t\t\t\tlastMode = 'insert';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (direction === 0) return completed(false);\r\n\r\n\t\t\t\t\t///realDragElRect = null;\r\n\t\t\t\t\tlastTarget = target;\r\n\r\n\t\t\t\t\tlastDirection = direction;\r\n\r\n\t\t\t\t\ttargetRect = geom.boundingRect(target);\r\n\r\n\t\t\t\t\tvar nextSibling = target.nextElementSibling,\r\n\t\t\t\t\t\tafter = false;\r\n\r\n\t\t\t\t\tafter = direction === 1;\r\n\r\n\t\t\t\t\tvar moveVector = this._onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);\r\n\r\n\t\t\t\t\tif (moveVector !== false) {\r\n\t\t\t\t\t\tif (moveVector === 1 || moveVector === -1) {\r\n\t\t\t\t\t\t\tafter = (moveVector === 1);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_silent = true;\r\n\t\t\t\t\t\tsetTimeout(_unsilent, 30);\r\n\r\n\t\t\t\t\t\tif (isOwner) {\r\n\t\t\t\t\t\t\tactiveSortable._hideClone();\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tactiveSortable._showClone(this);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (after && !nextSibling) {\r\n\t\t\t\t\t\t\tel.appendChild(dragEl);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\ttarget.parentNode.insertBefore(dragEl, after ? nextSibling : target);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// Undo chrome's scroll adjustment\r\n\t\t\t\t\t\tif (scrolledPastTop) {\r\n\t\t\t\t\t\t\tgeom.scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tdnd.parentEl = dragEl.parentNode; // actualization\r\n\r\n\t\t\t\t\t\t// must be done before animation\r\n\t\t\t\t\t\tif (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {\r\n\t\t\t\t\t\t\ttargetMoveDistance =  Math.abs(targetBeforeFirstSwap - geom.boundingRect(target)[side1]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tchanged();\r\n\r\n\t\t\t\t\t\treturn completed(true);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (el.contains(dragEl)) {\r\n\t\t\t\t\treturn completed(false);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t_onDrop(/**Event*/evt) {\r\n\t\t\tvar el = this.el,\r\n\t\t\t\toptions = this.options,\r\n\t\t\t\tsortable = this.sortable,\r\n\t\t\t\trootEl = dnd.active.elm(),\r\n\t\t\t\tdragEl = dnd.dragEl,\r\n\t\t\t\tputSortable = dnd.putSortable,\r\n\t\t\t\tparentEl = dnd.parentEl,\r\n\t\t\t\toldIndex = dnd.oldIndex,\r\n\t\t\t\toldDraggableIndex = dnd.oldDraggableIndex,\r\n\t\t\t\tnextEl = dnd.nextEl,\r\n\t\t\t\tnewIndex,\r\n\t\t\t\tnewDraggableIndex;\r\n\r\n\r\n\t\t\tisCircumstantialInvert = false;\r\n\t\t\tpastFirstInvertThresh = false;\r\n\r\n\r\n\t\t\tif (sortable.nativeDraggable) {\r\n\t\t\t\teventer.off(document, 'drop', this);\r\n\t\t\t}\r\n\r\n\t\t\tthis._offUpEvents();\r\n\r\n\t\t\tif (evt) {\r\n\t\t\t\tif (moved) {\r\n\t\t\t\t\tevt.cancelable && evt.preventDefault();\r\n\t\t\t\t\t!options.dropBubble && evt.stopPropagation();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//ghoster.remove();\r\n\r\n\t\t\t\tif (rootEl === parentEl || (putSortable && putSortable.lastPutMode !== 'clone')) {\r\n\t\t\t\t\t// Remove clone\r\n\t\t\t\t\tnoder.remove(dnd.cloneEl);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (dragEl) {\r\n\r\n\t\t\t\t\tdnd._disableDraggable(dragEl);\r\n\t\t\t\t\tdragEl.style['will-change'] = '';\r\n\r\n\t\t\t\t\t// Remove class'sd\r\n\t\t\t\t\tstyler.toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);\r\n\t\t\t\t\tstyler.toggleClass(dragEl, this.options.chosenClass, false);\r\n\r\n\t\t\t\t\t// Drag stop event\r\n\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'unchoose', dragEl, parentEl, rootEl, oldIndex, null, oldDraggableIndex, null, evt);\r\n\r\n\t\t\t\t\tif (rootEl !== parentEl) {\r\n\t\t\t\t\t\tnewIndex = _index(dragEl);\r\n\t\t\t\t\t\tnewDraggableIndex = _index(dragEl, options.draggable);\r\n\r\n\t\t\t\t\t\tif (newIndex >= 0) {\r\n\t\t\t\t\t\t\t// Add event\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(null, parentEl, 'add', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\r\n\t\t\t\t\t\t\t// Remove event\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'remove', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\r\n\t\t\t\t\t\t\t// drag from one list and drop into another\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(null, parentEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tputSortable && putSortable.save();\r\n\t\t\t\t\t}else {\r\n\t\t\t\t\t\tif (dragEl.nextSibling !== nextEl) {\r\n\t\t\t\t\t\t\t// Get the index of the dragged element within its parent\r\n\t\t\t\t\t\t\tnewIndex = _index(dragEl);\r\n\t\t\t\t\t\t\tnewDraggableIndex = _index(dragEl, options.draggable);\r\n\r\n\t\t\t\t\t\t\tif (newIndex >= 0) {\r\n\t\t\t\t\t\t\t\t// drag & drop within the same list\r\n\t\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'update', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'sort', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif (dnd.active) {\r\n\t\t\t\t\t\t/* jshint eqnull:true */\r\n\t\t\t\t\t\tif (newIndex == null || newIndex === -1) {\r\n\t\t\t\t\t\t\tnewIndex = oldIndex;\r\n\t\t\t\t\t\t\tnewDraggableIndex = oldDraggableIndex;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tsortable._dispatchEvent(this, rootEl, 'end', dragEl, parentEl, rootEl, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, evt);\r\n\r\n\t\t\t\t\t\t// Save sorting\r\n\t\t\t\t\t\tsortable.save();\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\tthis._nulling();\r\n\t\t}\r\n\r\n\t\t_offUpEvents () {\r\n\t\t\tvar ownerDocument = this.el.ownerDocument;\r\n\r\n\t\t\teventer.off(ownerDocument, 'mouseup', this._onDrop);\r\n\t\t\teventer.off(document, 'selectstart', this);\r\n\t\t}\r\n\r\n\t\t_nulling() {\r\n\r\n\t\t\tmoved =\tnull;\r\n\r\n\t\t}\r\n\r\n\t\thandleEvent (/**Event*/evt) {\r\n\t\t\tswitch (evt.type) {\r\n\t\t\t\tcase 'drop':\r\n\t\t\t\t\tthis._onDrop(evt);\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'dragenter':\r\n\t\t\t\tcase 'dragover':\r\n\t\t\t\t\tif (dnd.dragEl) {\r\n\t\t\t\t\t\tthis._onDragOver(evt);\r\n\t\t\t\t\t\t_globalDragOver(evt);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'selectstart':\r\n\t\t\t\t\tevt.preventDefault();\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tdestroy() {\r\n\t\t\tvar sortable = this.sortable;\r\n\r\n\t\t\t///if (sortable.nativeDraggable) {\r\n\t\t\t///\teventer.off(el, 'dragover', this);\r\n\t\t   ///\t\teventer.off(el, 'dragenter', this);\r\n\t\t\t///}\r\n\t\t\this._dndDroppable.destroy();\r\n\t\t}\r\n\r\n\r\n\t}\r\n\r\n\treturn Droppable;\r\n});"]}