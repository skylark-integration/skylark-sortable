{"version":3,"sources":["draggable.js"],"names":["define","langx","finder","styler","eventer","noder","touch","dnd","lastDownEl","savedInputChecked","_index","el","selector","index","nodeName","toUpperCase","cloneEl","matches","[object Object]","sortable","options","this","_elm","elm","mousy","on","_onMouseDown","evt","startIndex","startDraggableIndex","preventOnFilter","type","target","originalTarget","shadowRoot","path","composedPath","filter","root","length","inputs","getElementsByTagName","idx","checked","push","_saveInputCheckedState","test","button","disabled","isContentEditable","closest","draggable","log","tagName","className","call","_dispatchEvent","undefined","cancelable","preventDefault","split","some","criteria","trim","handle","ownerDocument","rootEl","dragEl","oldIndex","parentEl","nextEl","oldDraggableIndex","tapEvt","parentNode","nextSibling","activeGroup","group","clientX","clientY","_lastX","_lastY","style","transition","transform","ignore","forEach","ctx","iterator","list","i","n","_find","_disableDraggable","prepare","toggleClass","chosenClass","fallback","_this","dataTransfer","clone","_cloneId","defer","removeCloneOnHide","insertBefore","dragClass","effectAllowed","setData","css","awaitingDragStarted","_dragStartId","start","ghostClass","_nulling","bind","putSortable","clearTimeout","_dragStartTimer","cancel","end","off"],"mappings":"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","file":"../draggable.js","sourcesContent":["define([\r\n\t\"skylark-langx\",\r\n\t\"skylark-domx-finder\",\r\n\t\"skylark-domx-styler\",\r\n\t\"skylark-domx-eventer\",\r\n\t\"skylark-domx-noder\",\r\n\t\"skylark-devices-points/touch\",\r\n\t\"./dnd\"\r\n],function(langx,finder,styler,eventer,noder,touch,dnd){\r\n    var \r\n        lastDownEl,\r\n        scrolling,\r\n\r\n        savedInputChecked = [];\r\n\r\n    function _find(ctx, tagName, iterator) {\r\n        if (ctx) {\r\n            var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;\r\n\r\n            if (iterator) {\r\n                for (; i < n; i++) {\r\n                    iterator(list[i], i);\r\n                }\r\n            }\r\n\r\n            return list;\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n\t/**\r\n\t * Returns the index of an element within its parent for a selected set of\r\n\t * elements\r\n\t * @param  {HTMLElement} el\r\n\t * @param  {selector} selector\r\n\t * @return {number}\r\n\t */\r\n\tfunction _index(el, selector) {\r\n\t\treturn finder.index(el,function(el){\r\n\t\t\tif ((el.nodeName.toUpperCase() !== 'TEMPLATE') && el !== dnd.cloneEl && (!selector || finder.matches(el, selector))) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\treturn false;\t\t\t\r\n\t\t})\r\n\t}\t\r\n\r\n    function _saveInputCheckedState(root) {\r\n        savedInputChecked.length = 0;\r\n\r\n        var inputs = root.getElementsByTagName('input');\r\n        var idx = inputs.length;\r\n\r\n        while (idx--) {\r\n            var el = inputs[idx];\r\n            el.checked && savedInputChecked.push(el);\r\n        }\r\n    }\r\n\r\n\tclass Draggable {\r\n\t\tconstructor(sortable,options) {\r\n            this.sortable = sortable;\r\n            var el = this._elm = sortable.elm();\r\n            this.options = options;\r\n\r\n            // Bind events\r\n            touch.mousy(el);\r\n            eventer.on(el, 'mousedown', this._onMouseDown,this);\r\n\r\n\t\t}\r\n\r\n\t\telm() {\r\n\t\t\treturn this._elm;\r\n\t\t}\r\n\t\t//drag start \r\n        // handle moudedown event\r\n        _onMouseDown(/** Event|TouchEvent */evt) {\r\n            //if (!evt.cancelable) return;\r\n            var sortable = this.sortable,\r\n                el = this._elm,\r\n                options = this.options,\r\n                preventOnFilter = options.preventOnFilter,\r\n                type = evt.type,\r\n                target = evt.target,\r\n                originalTarget = evt.target.shadowRoot && ((evt.path && evt.path[0]) || (evt.composedPath && evt.composedPath()[0])) || target,\r\n                filter = options.filter,\r\n                startIndex,\r\n                startDraggableIndex;\r\n\r\n            _saveInputCheckedState(el);\r\n\r\n            // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.\r\n            ///if (dnd.dragEl) {\r\n            ///    return;\r\n            ///}\r\n\r\n            if (/mousedown/.test(type) && evt.button !== 0 || options.disabled) {\r\n                return; // only left button and enabled\r\n            }\r\n\r\n            // cancel dnd if original target is content editable\r\n            if (originalTarget.isContentEditable) {\r\n                return;\r\n            }\r\n\r\n            target = finder.closest(target, options.draggable, el, false);\r\n\r\n\r\n            if (lastDownEl === target) {\r\n                // Ignoring duplicate `down`\r\n                return;\r\n            }\r\n\r\n            dnd.log(\"_onTapStart\",target.tagName+\",\"+target.className);\r\n\r\n            // Get the index of the dragged element within its parent\r\n            startIndex = _index(target);\r\n            startDraggableIndex = _index(target, options.draggable);\r\n\r\n            // Check filter\r\n            if (typeof filter === 'function') {\r\n                if (filter.call(this, evt, target, this)) {\r\n                    sortable._dispatchEvent(sortable, originalTarget, 'filter', target, el, el, startIndex, undefined, startDraggableIndex);\r\n                    preventOnFilter && evt.cancelable && evt.preventDefault();\r\n                    return; // cancel dnd\r\n                }\r\n            }\r\n            else if (filter) {\r\n                filter = filter.split(',').some(function (criteria) {\r\n                    criteria = finder.closest(originalTarget, criteria.trim(), el, false);\r\n\r\n                    if (criteria) {\r\n                        sortable._dispatchEvent(sortable, criteria, 'filter', target, el, el, startIndex, undefined, startDraggableIndex);\r\n                        return true;\r\n                    }\r\n                });\r\n\r\n                if (filter) {\r\n                    preventOnFilter && evt.cancelable && evt.preventDefault();\r\n                    return; // cancel dnd\r\n                }\r\n            }\r\n\r\n            if (options.handle && !finder.closest(originalTarget, options.handle, el, false)) {\r\n                return;\r\n            }\r\n\r\n            // Prepare `dragstart`\r\n            var\r\n                ownerDocument = el.ownerDocument,\r\n                dragEl = dnd.dragEl,\r\n                rootEl,\r\n                parentEl = dnd.parentEl,\r\n                nextEl = dnd.nextEl,\r\n                oldIndex = dnd.oldIndex,\r\n                oldDraggableIndex = dnd.oldDraggableIndex,\r\n                tapEvt = dnd.tapEvt;\r\n\r\n            dnd.log(\"_prepareDragStart\",\"start\");\r\n            if (target && !dragEl && (target.parentNode === el)) {\r\n                rootEl = el;\r\n                dragEl = dnd.dragEl = target;\r\n                parentEl = dnd.parentEl= dragEl.parentNode;\r\n                nextEl = dnd.nextEl = dragEl.nextSibling;\r\n                lastDownEl = target;\r\n                dnd.activeGroup = this.options.group;\r\n                oldIndex = dnd.oldIndex = startIndex;\r\n                oldDraggableIndex = dnd.oldDraggableIndex =  startDraggableIndex;\r\n\r\n                tapEvt = dnd.tapEvt = {\r\n                    target: dragEl,\r\n                    clientX: evt.clientX,\r\n                    clientY: evt.clientY\r\n                };\r\n\r\n                this._lastX = evt.clientX;\r\n                this._lastY = evt.clientY;\r\n\r\n                dragEl.style['will-change'] = 'all';\r\n                // undo animation if needed\r\n                dragEl.style.transition = '';\r\n                dragEl.style.transform = '';\r\n\r\n                // Disable \"draggable\"\r\n                options.ignore.split(',').forEach(function (criteria) {\r\n                    _find(dragEl, criteria.trim(), dnd._disableDraggable);\r\n                });\r\n\r\n                // Bind the events: dragstart/dragend\r\n                ///sortable._triggerDragStart(evt, touch);\r\n\r\n                dnd.prepare(this,dnd.dragEl);\r\n\r\n                // Drag start event\r\n                sortable._dispatchEvent(sortable, rootEl, 'choose', dragEl, rootEl, rootEl, oldIndex, undefined, oldDraggableIndex);\r\n\r\n                // Chosen item\r\n                styler.toggleClass(dragEl, options.chosenClass, true);\r\n            }\r\n        }\r\n\r\n\r\n        _onDragStart(/**Event*/evt, /**boolean*/fallback) {\r\n            dnd.log(\"_onDragStart\",\"start\");\r\n            var _this = this,\r\n                dragEl = dnd.dragEl,\r\n                rootEl = this._elm;\r\n\r\n            var dataTransfer = evt.dataTransfer;\r\n            var options = _this.options;\r\n\r\n            // Setup clone\r\n            var cloneEl = dnd.cloneEl = noder.clone(dragEl,true);\r\n\r\n            cloneEl.draggable = false;\r\n            cloneEl.style['will-change'] = '';\r\n\r\n            //this._hideClone();\r\n\r\n            styler.toggleClass(cloneEl, _this.options.chosenClass, false);\r\n\r\n\r\n            // #1143: IFrame support workaround\r\n            _this._cloneId = langx.defer(function () {\r\n                if (!_this.options.removeCloneOnHide) {\r\n                    rootEl.insertBefore(cloneEl, dragEl);\r\n                }\r\n                _this.sortable._dispatchEvent(_this, rootEl, 'clone', dragEl);\r\n            });\r\n\r\n\r\n            if (!fallback){\r\n                styler.toggleClass(dragEl, options.dragClass, true);\r\n            } \r\n\r\n            // Set proper drop events\r\n            if (fallback) {\r\n                //dnd.ignoreNextClick = true;\r\n                //_this._loopId = setInterval(dnd._emulateDragOver.bind(dnd), 50);\r\n            } else {\r\n                // Undo what was set in _prepareDragStart before drag started\r\n                //eventer.off(document, 'mouseup', _this._onDrop); //TODO : lwf\r\n                ///eventer.off(document, 'touchend', _this._onDrop);\r\n                ///eventer.off(document, 'touchcancel', _this._onDrop);\r\n\r\n                if (dataTransfer) {\r\n                    dataTransfer.effectAllowed = 'move';\r\n                    options.setData && options.setData.call(_this, dataTransfer, dragEl);\r\n                }\r\n\r\n                ////eventer.on(document, 'drop', _this);\r\n\r\n                // #1276 fix:\r\n                styler.css(dragEl, 'transform', 'translateZ(0)');\r\n            }\r\n\r\n            dnd.awaitingDragStarted = true;\r\n\r\n\r\n\t        function _dragStarted(fallback, evt) {\r\n\t            dnd.awaitingDragStarted = false;\r\n\t            var dragEl = dnd.dragEl,\r\n\t                rootEl = this._elm,\r\n\t                oldIndex = dnd.oldIndex,\r\n\t                oldDraggableIndex = dnd.oldDraggableIndex;\r\n\r\n\t            if (rootEl && dragEl) {\r\n\t                //if (this.nativeDraggable) {\r\n\t                //    eventer.on(document, 'dragover', this._handleAutoScroll);\r\n\t                //    eventer.on(document, 'dragover', dnd._checkAlignment);\r\n\t                //}\r\n\t                dnd.start(this);\r\n\t                var options = this.options;\r\n\r\n\t                // Apply effect\r\n\t                !fallback && styler.toggleClass(dragEl, options.dragClass, false);\r\n\t                styler.toggleClass(dragEl, options.ghostClass, true);\r\n\r\n\t                // In case dragging an animated element\r\n\t                styler.css(dragEl, 'transform', '');\r\n\r\n\t                //dnd.active = this;\r\n\r\n\t                //fallback && this._appendGhost();\r\n\r\n\t                // Drag start event\r\n\t                this.sortable._dispatchEvent(this, rootEl, 'start', dragEl, rootEl, rootEl, oldIndex, undefined, oldDraggableIndex, undefined, evt);\r\n\t            } else {\r\n\t                this._nulling();\r\n\t            }\r\n\t        }\r\n\r\n            _this._dragStartId = langx.defer(_dragStarted.bind(_this, fallback, evt));\r\n            ///eventer.on(document, 'selectstart', _this);\r\n            ///if (Safari) {\r\n            ///    styler.css(document.body, 'user-select', 'none');\r\n            ///}\r\n        }\r\n\r\n        //\r\n        //\r\n\r\n        _onDragEnd(/**Event*/evt) {\r\n            var el = this._elm,\r\n                options = this.options,\r\n                dragEl = dnd.dragEl,\r\n                sortable = this.sortable,\r\n                putSortable = dnd.putSortable;\r\n\r\n            dnd.awaitingDragStarted = false;\r\n            scrolling = false;\r\n            //isCircumstantialInvert = false;\r\n            //pastFirstInvertThresh = false;\r\n\r\n            //clearInterval(this._loopId);\r\n\r\n            //clearInterval(pointerElemChangedInterval);\r\n\r\n            clearTimeout(this._dragStartTimer);\r\n\r\n\r\n            if (this._cloneId) {\r\n                this._cloneId.cancel();\r\n                this._cloneId = null;\r\n            }\r\n\r\n            if (this._dragStartId) {\r\n                this._dragStartId.cancel();\r\n                this._dragStartId = null;\r\n            }\r\n\r\n\r\n            // Unbind events\r\n            ///eventer.off(document, 'mousemove', this._onTouchMove);\r\n\r\n\r\n\r\n            ///if (Safari) {\r\n            ///    styler.css(document.body, 'user-select', '');\r\n           /// }\r\n\r\n\r\n            lastDownEl = null;\r\n\r\n            savedInputChecked.forEach(function (el) {\r\n                el.checked = true;\r\n            });\r\n\r\n\r\n            savedInputChecked.length = 0;\r\n\r\n           \t//this.dragEl = null;\r\n\r\n            dnd.end();\r\n\r\n        }\r\n\r\n        destroy() {\r\n            eventer.off(el, 'mousedown', this._onMouseDown);\r\n\r\n        }\r\n\t}\r\n\r\n\r\n\treturn Draggable;\r\n\r\n});"]}